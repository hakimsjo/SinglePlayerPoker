<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Single Player Poker Game</title>
    <!-- Bootstrap CSS CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" xintegrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Tailwind CSS CDN for easy styling (still useful for some utility classes not in Bootstrap) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .game-wrapper { /* New wrapper to handle main layout */
            position: relative; /* For positioning hamburger button */
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 1000px;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
        }
        .game-container {
            background-color: #2d3748;
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
        }
        .header-area {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
            margin-bottom: 20px;
            gap: 20px;
        }
        .left-header-content {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            flex-shrink: 0;
        }
        .header-area h1 {
            flex-shrink: 0;
            text-align: left;
            margin-bottom: 8px;
        }
        .game-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
        }
        .player-hand-and-deck { /* New container for player hand and deck */
            display: flex;
            justify-content: center;
            align-items: center; /* Align items vertically in the center */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 16px; /* Space between cards and deck */
            margin-bottom: 32px;
            width: 100%; /* Take full width to manage internal layout */
        }
        .player-hand { /* Ensure cards are displayed in a row */
            display: flex;
            justify-content: center;
            flex-wrap: wrap; /* Allow cards to wrap on smaller screens */
            gap: 16px; /* Space between cards */
            /* Removed margin-bottom as it's now handled by player-hand-and-deck gap */
            flex-grow: 1; /* Allow player hand to take available space */
        }
        .card {
            width: 100px;
            height: 140px;
            background-color: #fff; /* Fallback: White background */
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 0 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            color: #2d3748 !important; /* Force dark text color for card content */
            position: relative;
            user-select: none;
        }
        .card.selected {
            transform: translateY(-15px) scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            border: 3px solid #63b3ed;
        }
        .card.red {
            color: #e53e3e !important; /* Force red color for hearts and diamonds */
        }
        .card-rank {
            font-size: 2.2rem;
            font-weight: 700;
        }
        .card-suit {
            font-size: 2rem;
        }
        .card-top-left, .card-bottom-right {
            position: absolute;
            font-size: 1.2rem;
            font-weight: 600;
        }
        .card-top-left {
            top: 5px;
            left: 8px;
        }
        .card-bottom-right {
            bottom: 5px;
            right: 8px;
            transform: rotate(180deg);
        }
        .deck-area {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
            text-align: right;
            flex-shrink: 0;
        }
        .deck-card {
            width: 100px;
            height: 140px;
            background-color: #4a5568;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            /* Adjust font-size for the joker emoji to fill the card */
            font-size: 8rem; /* Increased size significantly */
            line-height: 1; /* Adjust line-height to prevent extra space */
            color: #cbd5e0;
        }
        /* Custom button styling to override Bootstrap defaults */
        .game-button {
            padding: 12px 24px !important;
            border-radius: 10px !important;
            font-weight: 600 !important;
            cursor: pointer !important;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out !important;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
            border: none !important;
            background: linear-gradient(145deg, #4299e1, #3182ce) !important; /* Blue gradient */
            color: white !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 8px !important;
        }
        .game-button:hover {
            background: linear-gradient(145deg, #3182ce, #2c5282) !important;
            transform: translateY(-2px) !important;
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2) !important;
        }
        .game-button:active {
            transform: translateY(0) !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2) !important;
        }
        .game-button:disabled {
            background: #a0aec0 !important;
            cursor: not-allowed !important;
            box-shadow: none !important;
            transform: none !important;
        }
        /* Message box styling (now a Bootstrap Modal) */
        .modal-content { /* Removed .message-box prefix */
            background-color: #2d3748;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            color: #e2e8f0;
        }
        .modal-header { /* Removed .message-box prefix */
            border-bottom: none;
        }
        .modal-title { /* Removed .message-box prefix */
            color: #63b3ed;
            font-weight: 700;
        }
        .btn-close { /* Removed .message-box prefix */
            filter: invert(1) grayscale(1) brightness(2);
        }
        .modal-body { /* Removed .message-box prefix */
            font-size: 1.1rem;
        }
        .modal-footer { /* Removed .message-box prefix */
            border-top: none;
            justify-content: center;
        }
        .modal-footer .btn { /* Removed .message-box prefix */
            background-color: #4299e1;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .modal-footer .btn:hover { /* Removed .message-box prefix */
            background-color: #3182ce;
        }

        /* New CSS for animations */
        .card-exit {
            animation: cardExit 0.3s forwards ease-out;
        }

        .card-enter {
            animation: cardEnter 0.3s forwards ease-in;
            opacity: 0; /* Start invisible */
            transform: translateY(20px) scale(0.8); /* Start slightly below and smaller */
        }

        @keyframes cardExit {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px) scale(0.5) rotate(15deg);
                opacity: 0;
            }
        }

        @keyframes cardEnter {
            0% {
                transform: translateY(50px) scale(0.5) rotate(-15deg);
                opacity: 0;
            }
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        /* High Score List Styling */
        #high-score-list {
            background-color: #1a202c;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            flex-grow: 1;
            max-width: 300px;
            max-height: 180px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #high-score-list h2 {
            font-size: 1.4rem;
            font-weight: 700;
            color: #63b3ed;
            text-align: center;
            margin-bottom: 10px;
        }
        #high-score-list ul {
            list-style: none;
            padding: 0;
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 5px;
        }
        #high-score-list li {
            background-color: #2d3748;
            padding: 6px 10px;
            border-radius: 6px;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.95rem;
        }
        #high-score-list li:last-child {
            margin-bottom: 0;
        }
        #high-score-list li span:first-child {
            font-weight: 600;
            color: #e2e8f0;
        }
        #high-score-list li span:last-child {
            color: #90cdf4;
        }
        #total-score {
            font-size: 1.2rem;
            font-weight: 700;
            color: #a7f3d0;
            text-align: center;
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid #4a5568;
        }
        #saved-total-score-display {
            font-size: 1rem;
            font-weight: 600;
            color: #cbd5e0;
            margin-left: 8px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            .player-hand-and-deck { /* Stack vertically on small screens */
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }
            .player-hand {
                flex-wrap: wrap;
                justify-content: center;
                margin-bottom: 0; /* No extra margin when stacked */
            }
            .card {
                width: 80px;
                height: 120px;
                margin: 5px;
            }
            .deck-card {
                margin-left: 0;
                margin-top: 10px;
            }
            .controls {
                flex-direction: column;
                gap: 15px;
                width: 100%;
            }
            .game-button {
                width: 100%;
            }
            .header-area {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            .header-area h1 {
                text-align: center;
            }
            .left-header-content {
                align-items: center;
                order: 1;
            }
            .game-info {
                align-items: center;
            }
            #high-score-list {
                max-width: 90%;
                max-height: 150px;
                order: 3;
            }
            .deck-area {
                order: 2;
                align-items: center;
                text-align: center;
            }
        }
    </style>
</head>
<body class="d-flex justify-content-center align-items-center min-vh-100 bg-gray-900 text-gray-100 p-3">

    <div class="game-wrapper">
        <!-- Side Menu (Offcanvas - still included for Bootstrap's JS, but not used as a visible menu) -->
        <div class="offcanvas offcanvas-start text-bg-dark" tabindex="-1" id="offcanvasMenu" aria-labelledby="offcanvasMenuLabel">
            <div class="offcanvas-header">
                <h5 class="offcanvas-title" id="offcanvasMenuLabel">Menu</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Close"></button>
            </div>
            <div class="offcanvas-body d-flex flex-column gap-3">
                <!-- No menu items here, as they are now direct buttons -->
            </div>
        </div>

        <div class="game-container container p-4 rounded-3 shadow-lg">
            <div class="header-area d-flex justify-content-between align-items-start w-100 mb-4">
                <div class="left-header-content d-flex flex-column align-items-start flex-shrink-0">
                    <h1 class="text-4xl font-bold text-blue-400" id="game-title">♠️ Single Player Poker</h1>
                    <div class="game-info d-flex flex-column align-items-start gap-1">
                        <div class="text-xl font-semibold" id="draw-count-label">Draws left: <span id="draw-count" class="text-blue-300">3</span></div>
                        <div class="text-xl font-semibold" id="hand-result-label">Best hand: <span id="hand-result" class="text-green-300"></span></div>
                    </div>
                </div>
                <!-- High Score List moved here -->
                <div id="high-score-list" class="high-score-list">
                    <h2 id="high-score-title">🏆 <span id="high-score-title-text">High Score</span> <span id="saved-total-score-display"></span></h2>
                    <ul id="score-list-items" class="list-unstyled">
                        <!-- Scores will be loaded here with JavaScript -->
                    </ul>
                    <div id="total-score" class="text-xl font-bold text-green-300 text-center mt-3 pt-2 border-top border-secondary">Total Score: 0</div>
                </div>
            </div>

            <!-- Player hand and Deck on the same row -->
            <div class="player-hand-and-deck d-flex justify-content-center align-items-center flex-wrap gap-3 mb-4">
                <div id="player-hand" class="player-hand d-flex justify-content-center flex-wrap gap-3">
                    <!-- Cards will be loaded here with JavaScript -->
                </div>
                <div class="deck-area d-flex flex-column align-items-end gap-1 flex-shrink-0">
                    <div id="deck" class="deck-card flex-shrink-0">
                        <span class="text-5xl">🃏</span>
                    </div>
                    <div class="text-lg font-medium text-gray-400" id="remaining-cards-label">Cards left: <span id="remaining-cards">52</span></div>
                </div>
            </div>


            <div class="controls d-flex flex-column flex-md-row gap-3 w-100 justify-content-center">
                <button id="draw-button" class="game-button btn btn-primary">🔄 Discard selected cards</button>
                <button id="stand-button" class="game-button btn btn-success">✋ Stand</button>
                <button id="continue-game-button" class="game-button btn btn-warning">▶️ Continue Game</button>
                <button id="new-game-button" class="game-button btn btn-info hidden">✨ New Game</button>
            </div>
            
            <!-- New row for sound, help, and language buttons -->
            <div class="additional-controls d-flex flex-column flex-md-row gap-3 w-100 justify-content-center mt-3">
                <button id="toggle-sound-button" class="game-button btn btn-secondary">🔊 Sound On</button>
                <button id="help-button" class="game-button btn btn-secondary">❓ Help</button>
                <button id="language-toggle-button" class="game-button btn btn-secondary">English 🇬🇧</button>
            </div>
        </div>
    </div>

    <!-- Message box (Bootstrap Modal) -->
    <div class="modal fade" id="messageBoxModal" tabindex="-1" aria-labelledby="messageBoxModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="messageBoxModalLabel">Game Message</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="messageBoxBody">
                    <!-- Message text goes here -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" xintegrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    
    <script>
        // Cookie functions
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        function eraseCookie(name) {
            document.cookie = name + '=; Max-Age=-99999999;';
        }

        // Function to show message box (now using Bootstrap Modal)
        function showMessageBox(message) {
            const messageBoxBody = document.getElementById('messageBoxBody');
            if (messageBoxBody) {
                messageBoxBody.innerHTML = message;
            }
            const messageBoxModal = new bootstrap.Modal(document.getElementById('messageBoxModal'));
            messageBoxModal.show();
        }

        // Card Class
        class Card {
            constructor(suit, rank) {
                this.suit = suit; // Suit: 'H' (Hearts), 'D' (Diamonds), 'C' (Clubs), 'S' (Spades)
                this.rank = rank; // Rank: '2', '3', ..., '10', 'J', 'Q', 'K', 'A'
            }

            // Returns a string representation of the card (e.g., "A♠")
            toString() {
                return `${this.rank}${this.getSuitSymbol()}`;
            }

            // Returns the symbol for the suit
            getSuitSymbol() {
                switch (this.suit) {
                    case 'H': return '♥';
                    case 'D': return '♦';
                    case 'C': return '♣';
                    case 'S': return '♠';
                    default: return '';
                }
            }

            // Checks if the card is red (Hearts or Diamonds)
            isRed() {
                return this.suit === 'H' || this.suit === 'D';
            }
        }

        // Deck Class
        class Deck {
            constructor() {
                this.cards = [];
                this.resetCardsOnly(); // Fill the deck with cards in order
                this.shuffle(); // Shuffle the deck immediately after filling
            }

            // Shuffles the deck using the Fisher-Yates algorithm
            shuffle() {
                for (let i = this.cards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]]; // Swap places
                }
            }

            // Creates a standard 52-card deck WITHOUT shuffling it
            resetCardsOnly() {
                const suits = ['H', 'D', 'C', 'S'];
                const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
                this.cards = []; // Ensure the deck is empty before filling
                for (const suit of suits) {
                    for (const rank of ranks) {
                        this.cards.push(new Card(suit, rank));
                    }
                }
            }

            // Resets the deck completely (fills and shuffles)
            reset() {
                this.resetCardsOnly();
                this.shuffle();
            }

            // Draws a card from the top of the deck
            draw() {
                if (this.cards.length === 0) {
                    showMessageBox(game.texts[game.currentLanguage].deckEmptyMessage);
                    return null;
                }
                return this.cards.pop();
            }

            // Returns the number of cards left in the deck
            remaining() {
                return this.cards.length;
            }
        }

        // Web Audio API for card dealing sound
        let audioContext = null; // Global AudioContext instance
        let lastCardDealSoundTime = 0;
        const cardDealSoundCooldown = 0.3; // 300ms cooldown

        // Function to play card dealing sound using Web Audio API
        async function playCardDealSound() {
            if (!game.isSoundEnabled) {
                console.log("Sound is disabled.");
                return;
            }

            // Lazy initialization of AudioContext
            if (!audioContext) {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!window.AudioContext) {
                    console.error("Web Audio API is not supported in this browser.");
                    return;
                }
                audioContext = new AudioContext();
                console.log("AudioContext created.");
            }

            // Resume context if suspended (required by most browsers for autoplay)
            if (audioContext.state === 'suspended') {
                try {
                    await audioContext.resume();
                    console.log("Audio context resumed successfully.");
                } catch (e) {
                    console.error("Error resuming audio context:", e);
                    return;
                }
            }

            const now = audioContext.currentTime;
            if (now - lastCardDealSoundTime > cardDealSoundCooldown) {
                console.log("Playing card deal sound at:", now);

                try {
                    const duration = 0.5; // Total duration of the shaking sound
                    const numClicks = 8; // Number of individual "clicks"
                    const clickDuration = 0.05; // Duration of each click

                    for (let i = 0; i < numClicks; i++) {
                        const startTime = audioContext.currentTime + (i * (duration / numClicks));

                        // Create a short burst of white noise for the "click"
                        const bufferSize = audioContext.sampleRate * clickDuration;
                        const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                        const output = noiseBuffer.getChannelData(0);
                        for (let j = 0; j < bufferSize; j++) {
                            output[j] = Math.random() * 0.8 - 0.4; // Slightly lower amplitude noise
                        }

                        const noiseSource = audioContext.createBufferSource();
                        noiseSource.buffer = noiseBuffer;

                        const gainNode = audioContext.createGain();
                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(0.4 + Math.random() * 0.2, startTime + 0.01); // Quick attack with slight randomness
                        gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + clickDuration); // Fast decay

                        // Add a bandpass filter for a "scratchier" sound
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'bandpass';
                        filter.frequency.setValueAtTime(1500, startTime);
                        filter.Q.setValueAtTime(0.8, startTime);

                        noiseSource.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        noiseSource.start(startTime);
                        noiseSource.stop(startTime + clickDuration);
                    }
                } catch (e) {
                    console.error("Failed to generate and play sound:", e);
                }

                lastCardDealSoundTime = now;
            } else {
                console.log("Card deal sound skipped due to cooldown.");
            }
        }

        // Text content for different languages
        const texts = {
            en: {
                gameTitle: "♠️ Single Player Poker", // Updated title
                drawsLeft: "Draws left:",
                bestHand: "Best hand:",
                discardButton: "🔄 Discard selected cards",
                standButton: "✋ Stand",
                continueButton: "▶️ Continue Game",
                newGameButton: "✨ New Game",
                soundOn: "🔊 Sound On",
                soundOff: "🔇 Sound Off",
                cardsLeft: "Cards left:",
                highScoreTitle: "High Score", // Changed to just text, emoji is in HTML
                savedTotalScore: "Saved Total Score:", // New text
                handLabel: "Hand",
                pointsLabel: "Points:",
                totalScore: "Total Score:",
                deckEmptyMessage: "The deck is empty!",
                selectCardsMessage: "Select at least one card to discard.",
                couldNotDiscardMessage: "The deck is empty, could not discard all cards.",
                allDrawsUsedMessage: (totalScore) => `Cards are out! Game over. 🎉 Your total score: ${totalScore}`,
                gameOverMessage: (totalScore) => `Game over. 🎉 Your total score: ${totalScore}`,
                standMessage: "You chose to stand. Your final hand is displayed.",
                menuTitle: "Menu",
                helpButton: "❓ Help", // New text for help button
                helpDescription: `
                    Welcome to Single Player Poker!
                    
                    The goal is to get the best possible poker hand.
                    
                    How to Play:
                    1.  You start with 5 cards.
                    2.  Click on the cards you want to discard (they will be highlighted).
                    3.  Click "Discard selected cards" to get new cards from the deck.
                    4.  You have 3 draws per game.
                    5.  You can "Stand" at any time to end your current hand.
                    6.  When a hand ends (after 3 draws or you stand), your hand's score is added to the High Score list.
                    7.  Click "Continue Game" to deal a new hand from the remaining cards in the deck.
                    8.  The game ends when there are not enough cards left to deal a full hand (5 cards).
                    9.  Your total score is saved and displayed.
                    
                    Poker Hand Ranks (Highest to Lowest):
                    - Royal Straight Flush (10)
                    - Straight Flush (9)
                    - Four of a Kind (8)
                    - Full House (7)
                    - Flush (6)
                    - Straight (5)
                    - Three of a Kind (4)
                    - Two Pair (3)
                    - One Pair (2)
                    - High Card (1)
                    
                    Good luck!
                `,
                langMenuTitle: "🌐 Language", // New text for language menu title
                backButton: "Back", // Text for back button
                langToggleEn: "English 🇬🇧", // Text for language toggle button when current is Swedish
                langToggleSv: "Svenska 🇸🇪"  // Text for language toggle button when current is English
            },
            sv: {
                gameTitle: "♠️ Single Player Poker", // Updated title
                drawsLeft: "Drag kvar:",
                bestHand: "Bästa hand:",
                discardButton: "🔄 Byt valda kort",
                standButton: "✋ Stanna",
                continueButton: "▶️ Fortsätt Spel",
                newGameButton: "✨ Nytt Spel",
                soundOn: "🔊 Ljud På",
                soundOff: "🔇 Ljud Av",
                cardsLeft: "Kort kvar:",
                highScoreTitle: "High Score", // Changed to just text, emoji is in HTML
                savedTotalScore: "Sparad total poäng:", // New text
                handLabel: "Hand",
                pointsLabel: "Poäng:",
                totalScore: "Total Poäng:",
                deckEmptyMessage: "Kortleken är tom!",
                selectCardsMessage: "Välj minst ett kort att byta ut.",
                couldNotDiscardMessage: "Kortleken är tom, kunde inte byta alla kort.",
                allDrawsUsedMessage: (totalScore) => `Korten är slut! Spelet är över. 🎉 Din totala poäng: ${totalScore}`,
                gameOverMessage: (totalScore) => `Spelet är över. 🎉 Din totala poäng: ${totalScore}`,
                standMessage: "Du valde att stanna. Din slutgiltiga hand visas.",
                menuTitle: "Meny",
                helpButton: "❓ Hjälp", // New text for help button
                helpDescription: `
                    Välkommen till Single Player Poker!
                    
                    Målet är att få den bästa möjliga pokerhanden.
                    
                    Så här spelar du:
                    1.  Du börjar med 5 kort.
                    2.  Klicka på de kort du vill göra dig av med (de markeras).
                    3.  Klicka på "Byt valda kort" för att få nya kort från högen.
                    4.  Du får göra 3 drag per spel.
                    5.  Du kan "Stanna" när som helst för att avsluta din nuvarande hand.
                    6.  När en hand är slut (efter 3 drag eller du stannar), läggs din hands poäng till i High Score-listan.
                    7.  Klicka på "Fortsätt Spel" för att få en ny hand från de återstående korten i högen.
                    8.  Spelet är slut när det inte finns tillräckligt med kort kvar för att dela ut en full hand (5 kort).
                    9.  Din totala poäng sparas och visas.
                    
                    Pokerhandrankning (högst till lägst):
                    - Royal Straight Flush (10)
                    - Straight Flush (9)
                    - Fyrtal (8)
                    - Kåk (Full House) (7)
                    - Färg (Flush) (6)
                    - Stege (Straight) (5)
                    - Triss (Three of a Kind) (4)
                    - Tvåpar (Two Pair) (3)
                    - Par (One Pair) (2)
                    - Högt Kort (High Card) (1)
                    
                    Lycka till!
                `,
                langMenuTitle: "🌐 Språk", // New text for language menu title
                backButton: "Tillbaka", // Text for back button
                langToggleEn: "English 🇬🇧", // Text for language toggle button when current is Swedish
                langToggleSv: "Svenska 🇸🇪"  // Text for language toggle button when current is English
            }
        };


        // Main game object
        const game = {
            deck: null,
            playerHand: [],
            drawsRemaining: 3,
            maxDraws: 3, // Max number of draws
            isGameOver: false,
            scores: [], // New array to store scores for each hand
            isSoundEnabled: true, // Sound on by default
            currentLanguage: 'en', // Default language is English
            texts: texts, // Reference to the language object

            // DOM Elements - Initialized in initializeDOMElements
            gameTitleEl: null,
            drawCountLabelEl: null,
            drawCountEl: null,
            handResultLabelEl: null,
            handResultEl: null,
            drawButton: null,
            standButton: null,
            continueButton: null,
            newGameButton: null,
            toggleSoundButton: null,
            helpButton: null, // New help button DOM element
            languageToggleButton: null, // New language toggle button
            remainingCardsLabelEl: null,
            remainingCardsEl: null,
            highScoreTitleEl: null,
            highScoreTitleTextEl: null, // Added for the text part of the H2
            savedTotalScoreDisplayEl: null, // The span inside H2 for saved score
            scoreListItemsEl: null,
            totalScoreEl: null,
            menuTitleEl: null, // No longer used for offcanvas title
            langSvButton: null, // No longer separate buttons
            langEnButton: null, // No longer separate buttons
            mainMenuOptionsEl: null, // No longer used for menu sections
            languageOptionsEl: null, // No longer used for menu sections
            langMenuButton: null, // No longer used for menu navigation
            backButton: null, // No longer used for menu navigation

            // New method to initialize DOM elements
            initializeDOMElements() {
                this.gameTitleEl = document.getElementById('game-title');
                this.drawCountLabelEl = document.getElementById('draw-count-label');
                this.drawCountEl = this.drawCountLabelEl ? this.drawCountLabelEl.querySelector('#draw-count') : null;
                this.handResultLabelEl = document.getElementById('hand-result-label');
                this.handResultEl = this.handResultLabelEl ? this.handResultLabelEl.querySelector('#hand-result') : null;

                this.drawButton = document.getElementById('draw-button');
                this.standButton = document.getElementById('stand-button');
                this.continueButton = document.getElementById('continue-game-button');
                this.newGameButton = document.getElementById('new-game-button');
                this.toggleSoundButton = document.getElementById('toggle-sound-button');
                this.helpButton = document.getElementById('help-button'); // Initialize new button
                this.languageToggleButton = document.getElementById('language-toggle-button'); // Initialize new language toggle button
                this.remainingCardsLabelEl = document.getElementById('remaining-cards-label');
                this.remainingCardsEl = this.remainingCardsLabelEl ? this.remainingCardsLabelEl.querySelector('#remaining-cards') : null;
                
                this.highScoreListEl = document.getElementById('high-score-list');
                this.highScoreTitleEl = document.getElementById('high-score-title'); // Parent of high-score-title-text and saved-total-score-display
                this.highScoreTitleTextEl = document.getElementById('high-score-title-text'); // Get the span for the text
                this.savedTotalScoreDisplayEl = document.getElementById('saved-total-score-display'); // Get the span for saved score

                this.scoreListItemsEl = document.getElementById('score-list-items');
                this.totalScoreEl = document.getElementById('total-score');
                // this.menuTitleEl = document.getElementById('offcanvasMenuLabel'); // No longer used for offcanvas title
                // this.langSvButton = document.getElementById('lang-sv-button'); // No longer separate buttons
                // this.langEnButton = document.getElementById('lang-en-button'); // No longer separate buttons

                // No longer needed for menu sections
                // this.mainMenuOptionsEl = document.getElementById('main-menu-options');
                // this.languageOptionsEl = document.getElementById('language-options');
                // this.langMenuButton = document.getElementById('lang-menu-button');
                // this.backButton = document.getElementById('back-button');
                this.playerHandEl = document.getElementById('player-hand'); // Ensure playerHandEl is initialized here
            },

            // Helper function to create a card DOM element
            createCardElement(card, index) {
                const cardEl = document.createElement('div');
                cardEl.classList.add('card', 'rounded-xl', 'flex', 'flex-col', 'justify-between', 'items-center', 'p-2', 'shadow-lg', 'transition-all', 'duration-200');
                if (card.isRed()) {
                    cardEl.classList.add('red');
                }
                cardEl.dataset.index = index; // Store index to know which card was selected

                cardEl.innerHTML = `
                    <div class="card-top-left">${card.rank}${card.getSuitSymbol()}</div>
                    <div class="card-rank">${card.rank}</div>
                    <div class="card-suit">${card.getSuitSymbol()}</div>
                    <div class="card-bottom-right">${card.rank}${card.getSuitSymbol()}</div>
                `;
                cardEl.addEventListener('click', () => this.toggleCardSelection(cardEl));
                return cardEl;
            },

            // Sets the language of the game UI
            setLanguage(lang) {
                this.currentLanguage = lang;
                const t = this.texts[lang];

                if (this.gameTitleEl) {
                    this.gameTitleEl.textContent = t.gameTitle;
                } else {
                    console.error("Error: gameTitleEl is null. Cannot set game title. Re-initializing and trying again.");
                    this.gameTitleEl = document.getElementById('game-title');
                    if (this.gameTitleEl) {
                         this.gameTitleEl.textContent = t.gameTitle;
                    }
                }
                
                if (this.drawCountLabelEl) {
                    this.drawCountLabelEl.innerHTML = `${t.drawsLeft} <span id="draw-count" class="text-blue-300"></span>`;
                    this.drawCountEl = document.getElementById('draw-count'); // Re-get reference
                    if (this.drawCountEl) this.drawCountEl.textContent = this.drawsRemaining;
                } else {
                    console.error("Error: drawCountLabelEl is null. Cannot set draws left label.");
                    this.drawCountLabelEl = document.getElementById('draw-count-label');
                    if (this.drawCountLabelEl) {
                        this.drawCountLabelEl.innerHTML = `${t.drawsLeft} <span id="draw-count" class="text-blue-300"></span>`;
                        this.drawCountEl = document.getElementById('draw-count');
                        if (this.drawCountEl) this.drawCountEl.textContent = this.drawsRemaining;
                    }
                }

                if (this.handResultLabelEl) {
                    this.handResultLabelEl.innerHTML = `${t.bestHand} <span id="hand-result" class="text-green-300"></span>`;
                    this.handResultEl = document.getElementById('hand-result'); // Re-get reference
                    if (this.handResultEl) this.handResultEl.textContent = this.evaluateHand(this.playerHand).name;
                } else {
                    console.error("Error: handResultLabelEl is null. Cannot set best hand label.");
                    this.handResultLabelEl = document.getElementById('hand-result-label');
                    if (this.handResultLabelEl) {
                        this.handResultLabelEl.innerHTML = `${t.bestHand} <span id="hand-result" class="text-green-300"></span>`;
                        this.handResultEl = document.getElementById('hand-result');
                        if (this.handResultEl) this.handResultEl.textContent = this.evaluateHand(this.playerHand).name;
                    }
                }

                if (this.drawButton) this.drawButton.textContent = t.discardButton;
                if (this.standButton) this.standButton.textContent = t.standButton;
                if (this.continueButton) this.continueButton.textContent = t.continueButton;
                if (this.newGameButton) this.newGameButton.textContent = t.newGameButton;
                if (this.toggleSoundButton) this.toggleSoundButton.textContent = this.isSoundEnabled ? t.soundOn : t.soundOff;
                if (this.helpButton) this.helpButton.textContent = t.helpButton; // Set text for new help button
                
                // Update language toggle button
                if (this.languageToggleButton) {
                    if (lang === 'en') {
                        this.languageToggleButton.innerHTML = `${this.texts['sv'].langToggleSv} <img src="https://placehold.co/20x15/fff/000?text=SE" alt="Swedish Flag" class="flag-icon">`; // Show Swedish flag to switch to Swedish
                    } else {
                        this.languageToggleButton.innerHTML = `${this.texts['en'].langToggleEn} <img src="https://placehold.co/20x15/fff/000?text=US" alt="US Flag" class="flag-icon">`; // Show US flag to switch to English
                    }
                }

                if (this.remainingCardsLabelEl) {
                    this.remainingCardsLabelEl.innerHTML = `${t.cardsLeft} <span id="remaining-cards"></span>`;
                    this.remainingCardsEl = document.getElementById('remaining-cards'); // Re-get reference
                    if (this.remainingCardsEl) this.remainingCardsEl.textContent = this.deck ? this.deck.remaining() : 52;
                } else {
                    console.error("Error: remainingCardsLabelEl is null. Cannot set cards left label.");
                    this.remainingCardsLabelEl = document.getElementById('remaining-cards-label');
                    if (this.remainingCardsLabelEl) {
                        this.remainingCardsLabelEl.innerHTML = `${t.cardsLeft} <span id="remaining-cards"></span>`;
                        this.remainingCardsEl = document.getElementById('remaining-cards');
                        if (this.remainingCardsEl) this.remainingCardsEl.textContent = this.deck ? this.deck.remaining() : 52;
                    }
                }

                // Update High Score title text
                if (this.highScoreTitleTextEl) {
                    this.highScoreTitleTextEl.textContent = t.highScoreTitle;
                } else {
                    console.error("Error: highScoreTitleTextEl is null. Cannot set high score title text.");
                    this.highScoreTitleTextEl = document.getElementById('high-score-title-text');
                    if (this.highScoreTitleTextEl) this.highScoreTitleTextEl.textContent = t.highScoreTitle;
                }

                // Update saved total score display
                if (this.savedTotalScoreDisplayEl) {
                    const savedScore = getCookie('pokerTotalScore');
                    this.savedTotalScoreDisplayEl.textContent = savedScore ? `(${savedScore}p)` : ''; // Format (XXp)
                } else {
                    console.error("Error: savedTotalScoreDisplayEl is null. Cannot set saved total score.");
                    this.savedTotalScoreDisplayEl = document.getElementById('saved-total-score-display');
                    if (this.savedTotalScoreDisplayEl) {
                        const savedScore = getCookie('pokerTotalScore');
                        this.savedTotalScoreDisplayEl.textContent = savedScore ? `(${savedScore}p)` : '';
                    }
                }


                // Re-render high score list and total score to update labels
                this.renderHighScoreList();
            },

            // Shows the main menu options (no longer applicable with direct buttons)
            showMainMenu() {
                // This function is no longer directly used as there's no offcanvas menu navigation
                // It might be called by startGame, but its effects are now minimal.
            },

            // Shows the language selection options (no longer applicable with direct buttons)
            showLanguageOptions() {
                // This function is no longer directly used. Language toggle is a single button.
            },

            // Starts a new game
            startGame() {
                this.initializeDOMElements(); // Call this first to ensure elements are ready
                this.deck = new Deck();
                this.scores = []; // Clear scores from previous game
                this.isGameOver = false;

                this.dealNewRound(); // Start the first round
                this.setLanguage(this.currentLanguage); // Set language on start
                // this.showMainMenu(); // No longer needed
            },

            // Deals a new hand for a new round
            dealNewRound() {
                // Check if there are enough cards for a new hand
                if (this.deck.remaining() < 5) {
                    this.endGame(true); // Game over if cards run out
                    return;
                }

                this.playerHand = [];
                this.drawsRemaining = this.maxDraws;

                // Show game buttons, hide continue/new game
                if (this.drawButton) this.drawButton.classList.remove('hidden');
                if (this.standButton) this.standButton.classList.remove('hidden');
                if (this.newGameButton) this.newGameButton.classList.add('hidden');
                
                // Fortsätt-knappen är alltid synlig men inaktiveras vid ny runda
                if (this.continueButton) this.continueButton.disabled = true; 

                if (this.drawButton) this.drawButton.disabled = false;
                if (this.standButton) this.standButton.disabled = false;

                for (let i = 0; i < 5; i++) {
                    const card = this.deck.draw();
                    if (card) {
                        this.playerHand.push(card);
                    }
                }
                this.updateUI();
                playCardDealSound(); // Play sound when new hand is dealt
            },

            // Updates the UI
            updateUI() {
                // Only render hand if not in the middle of card animation
                if (!this.isAnimatingCards) {
                    this.renderHand();
                }
                if (this.drawCountEl) this.drawCountEl.textContent = this.drawsRemaining;
                if (this.remainingCardsEl) this.remainingCardsEl.textContent = this.deck.remaining();
                const handEvaluation = this.evaluateHand(this.playerHand);
                if (this.handResultEl) this.handResultEl.textContent = handEvaluation.name;

                // Handle button states
                if (this.isGameOver) {
                    if (this.drawButton) this.drawButton.disabled = true;
                    if (this.standButton) this.standButton.disabled = true;
                    if (this.continueButton) this.continueButton.disabled = true; // Disable continue when game is completely over
                    if (this.newGameButton) this.newGameButton.classList.remove('hidden'); // Show New Game button
                } else if (this.drawsRemaining === 0) {
                    if (this.drawButton) this.drawButton.disabled = true; // No more draws in this hand
                    if (this.standButton) this.standButton.disabled = true; // Cannot stand if draws are out
                    if (this.continueButton) this.continueButton.disabled = false; // Enable continue when round is over
                    if (this.newGameButton) this.newGameButton.classList.add('hidden');
                } else {
                    if (this.drawButton) this.drawButton.disabled = false;
                    if (this.standButton) this.standButton.disabled = false;
                    if (this.continueButton) this.continueButton.disabled = true; // Inaktivera fortsätt under pågående runda
                    if (this.newGameButton) this.newGameButton.classList.add('hidden');
                }
            },

            // Renders the player's hand in the DOM
            renderHand() {
                if (this.playerHandEl) { // Add check for playerHandEl
                    this.playerHandEl.innerHTML = ''; // Clear existing cards
                    this.playerHand.forEach((card, index) => {
                        const cardEl = this.createCardElement(card, index);
                        this.playerHandEl.appendChild(cardEl);
                    });
                }
            },

            // Toggles card selection
            toggleCardSelection(cardEl) {
                if (this.isGameOver || this.drawsRemaining === 0) return; // Cannot select cards if game is over or no draws left
                cardEl.classList.toggle('selected');
            },

            // Handles card exchange with animations
            async handleDraw() {
                if (this.drawsRemaining === 0) {
                    return; // Abort if no draws left
                }

                const selectedCards = Array.from(this.playerHandEl.children).filter(cardEl =>
                    cardEl.classList.contains('selected')
                );

                if (selectedCards.length === 0) {
                    showMessageBox(this.texts[this.currentLanguage].selectCardsMessage);
                    return;
                }

                if (this.drawButton) this.drawButton.disabled = true; // Disable buttons during animation
                if (this.standButton) this.standButton.disabled = true;
                if (this.continueButton) this.continueButton.disabled = true; // Disable continue during animation
                this.isAnimatingCards = true; // Mark that animation is in progress

                let cardsReplacedCount = 0;
                const animationDelay = 300; // Matches CSS animation duration

                // Animate out selected cards first
                const exitPromises = selectedCards.map(cardEl => {
                    return new Promise(resolve => {
                        cardEl.classList.add('card-exit');
                        setTimeout(() => {
                            cardEl.remove(); // Remove card from DOM after exit animation
                            resolve();
                        }, animationDelay);
                    });
                });

                await Promise.all(exitPromises); // Wait until all exit animations are complete

                // Play sound when cards are exchanged
                playCardDealSound();

                // Replace cards and animate in new ones
                const entryPromises = [];
                for (const cardEl of selectedCards) {
                    const indexToReplace = parseInt(cardEl.dataset.index);
                    const newCard = this.deck.draw();

                    if (newCard) {
                        this.playerHand[indexToReplace] = newCard;
                        const newCardEl = this.createCardElement(newCard, indexToReplace);
                        newCardEl.classList.add('card-enter'); // Add entry animation
                        
                        // Find the correct position to insert the new card
                        const referenceNode = this.playerHandEl.children[indexToReplace];
                        if (referenceNode) {
                            this.playerHandEl.insertBefore(newCardEl, referenceNode);
                        } else {
                            this.playerHandEl.appendChild(newCardEl);
                        }

                        entryPromises.push(new Promise(resolve => {
                            setTimeout(() => {
                                newCardEl.classList.remove('card-enter');
                                resolve();
                            }, animationDelay);
                        }));
                        cardsReplacedCount++;
                    } else {
                        showMessageBox(this.texts[this.currentLanguage].couldNotDiscardMessage);
                        this.isGameOver = true; // Game is over if deck is empty
                        break; // Abort if deck is empty
                    }
                }

                await Promise.all(entryPromises); // Wait until all entry animations are complete

                this.isAnimatingCards = false; // Animation complete

                if (cardsReplacedCount > 0) {
                    this.drawsRemaining--;
                }

                this.updateUI(); // Update UI after animations and card exchanges

                if (this.drawsRemaining === 0 || this.isGameOver) {
                    this.endHand(); // End the hand when draws are out or game is over
                }
            },

            // Handles player choosing to stand
            handleStand() {
                this.endHand(); // End the hand
            },

            // Ends the current hand
            endHand() {
                // Save the score for the current hand
                const handEvaluation = this.evaluateHand(this.playerHand);
                this.scores.push(handEvaluation); // Save the entire object
                this.drawsRemaining = 0; // Set draws left to 0 to activate "Continue Game" button
                this.updateUI(); // Update UI to show buttons correctly
                this.renderHighScoreList(); // Update high score list after each hand

                // Check if there are enough cards for the next round
                if (this.deck.remaining() < 5) {
                    this.endGame(true); // Game is completely over
                }
            },

            // Ends the entire game (when the deck is empty)
            endGame(deckEmpty = false) {
                this.isGameOver = true;
                this.updateUI(); // Update UI to show New Game button and hide others

                let finalMessage = "";
                let totalScore = this.scores.reduce((sum, hand) => sum + hand.score, 0);

                // Save total score to cookie
                setCookie('pokerTotalScore', totalScore, 365); // Save for 365 days

                if (deckEmpty) {
                    finalMessage = this.texts[this.currentLanguage].allDrawsUsedMessage(totalScore);
                } else {
                    finalMessage = this.texts[this.currentLanguage].gameOverMessage(totalScore);
                }
                showMessageBox(finalMessage);
                // High score list is already visible and updated
            },

            // Function for evaluating the poker hand and returning name + score
            evaluateHand(hand) {
                if (hand.length !== 5) return { name: "Invalid hand", score: 0 };

                const ranks = hand.map(card => card.rank);
                const suits = hand.map(card => card.suit);

                const rankValues = ranks.map(r => {
                    if (r === 'J') return 11;
                    if (r === 'Q') return 12;
                    if (r === 'K') return 13;
                    if (r === 'A') return 14;
                    return parseInt(r);
                }).sort((a, b) => a - b);

                const rankCounts = {};
                ranks.forEach(r => { rankCounts[r] = (rankCounts[r] || 0) + 1; });
                const suitCounts = {};
                suits.forEach(s => { suitCounts[s] = (suitCounts[s] || 0) + 1; });

                const numPairs = Object.values(rankCounts).filter(count => count === 2).length;
                const numThrees = Object.values(rankCounts).filter(count => count === 3).length;
                const numFours = Object.values(rankCounts).filter(count => count === 4).length;
                const isFlush = Object.values(suitCounts).some(count => count >= 5);

                let isStraight = true;
                // Handle Ace as low for straight (A, 2, 3, 4, 5)
                const lowAceRankValues = rankValues.includes(14) ? [...rankValues.filter(r => r !== 14), 1].sort((a, b) => a - b) : rankValues;

                for (let i = 0; i < lowAceRankValues.length - 1; i++) {
                    if (lowAceRankValues[i + 1] !== lowAceRankValues[i] + 1) {
                        isStraight = false;
                        break;
                    }
                }
                // If not a low ace straight, try normal straight
                if (!isStraight) {
                    isStraight = true;
                    for (let i = 0; i < rankValues.length - 1; i++) {
                        if (rankValues[i + 1] !== rankValues[i] + 1) {
                            isStraight = false;
                            break;
                        }
                        // Special case for Ace as highest card in straight (10, J, Q, K, A)
                        if (rankValues[i] === 10 && rankValues[i+1] === 11 && rankValues[i+2] === 12 && rankValues[i+3] === 13 && rankValues[i+4] === 14) {
                            isStraight = true;
                            break;
                        }
                    }
                }

                // Evaluate hand in descending order of strength
                if (isStraight && isFlush && (rankValues[4] === 14 && rankValues[0] === 10)) return { name: "Royal Straight Flush!", score: 10 };
                if (isStraight && isFlush) return { name: "Straight Flush", score: 9 };
                if (numFours === 1) return { name: "Four of a Kind", score: 8 };
                if (numThrees === 1 && numPairs === 1) return { name: "Full House", score: 7 };
                if (isFlush) return { name: "Flush", score: 6 };
                if (isStraight) return { name: "Straight", score: 5 };
                if (numThrees === 1) return { name: "Three of a Kind", score: 4 };
                if (numPairs === 2) return { name: "Two Pair", score: 3 };
                if (numPairs === 1) return { name: "One Pair", score: 2 };

                const highestRank = ranks[rankValues.length - 1];
                return { name: `High Card: ${highestRank}`, score: 1 };
            },

            // Renders the high score list
            renderHighScoreList() {
                if (this.scoreListItemsEl) { // Add check for scoreListItemsEl
                    this.scoreListItemsEl.innerHTML = ''; // Clear existing list items
                    let totalScore = 0;
                    // Iterate in reverse to show latest result at the top
                    for (let i = this.scores.length - 1; i >= 0; i--) {
                        const handResult = this.scores[i];
                        const listItem = document.createElement('li');
                        // Use original index for display (Hand 1, Hand 2, etc.)
                        listItem.innerHTML = `<span>${this.texts[this.currentLanguage].handLabel} ${i + 1}: ${handResult.name}</span> <span>${this.texts[this.currentLanguage].pointsLabel} ${handResult.score}</span>`;
                        this.scoreListItemsEl.appendChild(listItem);
                        totalScore += handResult.score;
                    }
                    if (this.totalScoreEl) { // Add check for totalScoreEl
                        this.totalScoreEl.textContent = `${this.texts[this.currentLanguage].totalScore} ${totalScore}`;
                    }
                }
                // Update saved total score display
                if (this.savedTotalScoreDisplayEl) { // Changed from savedTotalScoreEl to savedTotalScoreDisplayEl
                    const savedScore = getCookie('pokerTotalScore');
                    this.savedTotalScoreDisplayEl.textContent = savedScore ? `(${savedScore}p)` : '';
                }
            },

            // Toggles sound on/off
            toggleSound() {
                this.isSoundEnabled = !this.isSoundEnabled;
                if (this.toggleSoundButton) { // Add check for toggleSoundButton
                    this.toggleSoundButton.textContent = this.isSoundEnabled ? this.texts[this.currentLanguage].soundOn : this.texts[this.currentLanguage].soundOff;
                }
            }
        };

        // Event listeners for buttons
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize AudioContext on first user interaction
            let audioContextInitialized = false;
            const initializeAudioContext = async () => {
                if (!audioContextInitialized) {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!window.AudioContext) {
                        console.error("Web Audio API is not supported in this browser.");
                        return;
                    }
                    if (!audioContext) { // Create context only once
                        audioContext = new AudioContext();
                        console.log("AudioContext created.");
                    }
                    if (audioContext.state === 'suspended') {
                        try {
                            await audioContext.resume();
                            console.log("Audio context resumed successfully.");
                        } catch (e) {
                            console.error("Error resuming audio context:", e);
                            return;
                        }
                    }
                    audioContextInitialized = true;
                    console.log("Audio context is now running.");
                }
            };

            // Call initializeDOMElements at the very beginning of DOMContentLoaded
            game.initializeDOMElements();

            // Attach initializeAudioContext to any button click, but only run once
            document.body.addEventListener('click', (event) => {
                if (event.target.tagName === 'BUTTON') {
                    initializeAudioContext();
                }
            }, { once: true });

            if (game.drawButton) game.drawButton.addEventListener('click', () => game.handleDraw());
            if (game.standButton) game.standButton.addEventListener('click', () => game.handleStand());
            if (game.continueButton) game.continueButton.addEventListener('click', () => game.dealNewRound());
            if (game.newGameButton) game.newGameButton.addEventListener('click', () => game.startGame());
            if (game.toggleSoundButton) game.toggleSoundButton.addEventListener('click', () => game.toggleSound()); // Event listener for sound button
            if (game.helpButton) game.helpButton.addEventListener('click', () => { // Event listener for help button
                showMessageBox(game.texts[game.currentLanguage].helpDescription);
            });

            // Language toggle button logic
            const languageToggleButton = document.getElementById('language-toggle-button');
            if (languageToggleButton) {
                languageToggleButton.addEventListener('click', () => {
                    if (game.currentLanguage === 'en') {
                        game.setLanguage('sv');
                    } else {
                        game.setLanguage('en');
                    }
                });
            }

            // Start the game when the page loads
            game.startGame();
        });
    </script>
</body>
</html>