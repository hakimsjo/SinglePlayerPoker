<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Single Player Poker Game</title>
    <!-- Bootstrap CSS CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" xintegrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Tone.js for sound generation (moved to head with defer) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js" crossorigin="anonymous" defer></script>
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .game-wrapper { /* New wrapper to handle main layout */
            position: relative; /* For positioning hamburger button */
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 1000px;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
        }
        .game-container {
            background-color: #2d3748; /* Darker gray background for container */
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            width: 100%; /* Fill available width */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
        }
        .header-area { /* New div for title, high score, and deck */
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* Align to top */
            width: 100%;
            margin-bottom: 20px; /* More space below title */
            gap: 20px; /* Spacing between elements */
        }
        .left-header-content { /* New container for title and game info */
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* Left-align content */
            flex-shrink: 0;
        }
        .header-area h1 {
            flex-shrink: 0; /* Prevent title from shrinking */
            text-align: left; /* Ensure left alignment */
            margin-bottom: 8px; /* Less margin below title */
        }
        .game-info { /* Style for "Draws left" and "Best hand" */
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* Left-align text */
            gap: 4px; /* Less space between lines */
        }
        .card {
            width: 100px;
            height: 140px;
            background-color: #fff; /* Fallback: White background */
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 0 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            color: #2d3748; /* Fallback: Dark text for cards */
            position: relative;
            user-select: none;
        }
        .card.selected {
            transform: translateY(-15px) scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            border: 3px solid #63b3ed; /* Blue border for selected cards */
        }
        .card.red {
            color: #e53e3e; /* Red color for hearts and diamonds */
        }
        .card-rank {
            font-size: 2.2rem;
            font-weight: 700;
        }
        .card-suit {
            font-size: 2rem;
        }
        .card-top-left, .card-bottom-right {
            position: absolute;
            font-size: 1.2rem;
            font-weight: 600;
        }
        .card-top-left {
            top: 5px;
            left: 8px;
        }
        .card-bottom-right {
            bottom: 5px;
            right: 8px;
            transform: rotate(180deg);
        }
        .deck-area {
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* Right-align deck info */
            gap: 4px;
            text-align: right; /* Text inside right-aligned */
            flex-shrink: 0; /* Prevent deck from shrinking */
        }
        .deck-card {
            width: 100px;
            height: 140px;
            background-color: #4a5568; /* Dark gray for card back */
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            color: #cbd5e0;
        }
        .game-button {
            padding: 12px 24px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: none;
            background: linear-gradient(145deg, #4299e1, #3182ce); /* Blue gradient */
            color: white;
            display: flex; /* Use flexbox to center emoji and text */
            align-items: center;
            justify-content: center;
            gap: 8px; /* Space between emoji and text */
        }
        .game-button:hover {
            background: linear-gradient(145deg, #3182ce, #2c5282);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }
        .game-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .game-button:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .message-box {
            background-color: #2d3748;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            text-align: center;
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 15px;
            max-width: 400px;
            width: 90%;
        }
        .message-box button {
            background-color: #4299e1;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .message-box button:hover {
            background-color: #3182ce;
        }

        /* New CSS for animations */
        .card-exit {
            animation: cardExit 0.3s forwards ease-out;
        }

        .card-enter {
            animation: cardEnter 0.3s forwards ease-in;
            opacity: 0; /* Start invisible */
            transform: translateY(20px) scale(0.8); /* Start slightly below and smaller */
        }

        @keyframes cardExit {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px) scale(0.5) rotate(15deg);
                opacity: 0;
            }
        }

        @keyframes cardEnter {
            0% {
                transform: translateY(50px) scale(0.5) rotate(-15deg);
                opacity: 0;
            }
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        /* High Score List Styling */
        #high-score-list {
            background-color: #1a202c;
            padding: 10px; /* Adjusted padding to fit better in the middle */
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            flex-grow: 1; /* Allow it to take available space */
            max-width: 300px; /* Limit max width for symmetry */
            max-height: 180px; /* Make it scrollable */
            overflow-y: auto; /* Enable vertical scrolling */
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #high-score-list h2 {
            font-size: 1.4rem; /* Smaller heading to fit better */
            font-weight: 700;
            color: #63b3ed;
            text-align: center;
            margin-bottom: 10px;
        }
        #high-score-list ul {
            list-style: none;
            padding: 0;
            flex-grow: 1; /* Allow the list to grow within its container */
            overflow-y: auto; /* Ensure the list is scrollable inside */
            padding-right: 5px; /* Make space for the scrollbar */
        }
        #high-score-list li {
            background-color: #2d3748;
            padding: 6px 10px; /* Made rows smaller */
            border-radius: 6px; /* Less rounded corners */
            margin-bottom: 4px; /* Less margin */
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.95rem; /* Smaller text size */
        }
        #high-score-list li:last-child {
            margin-bottom: 0;
        }
        #high-score-list li span:first-child {
            font-weight: 600;
            color: #e2e8f0;
        }
        #high-score-list li span:last-child {
            color: #90cdf4;
        }
        #total-score {
            font-size: 1.2rem; /* Smaller total score text */
            font-weight: 700;
            color: #a7f3d0; /* Light green for total score */
            text-align: center;
            margin-top: 10px; /* Less top margin */
            padding-top: 8px; /* Less padding */
            border-top: 1px solid #4a5568;
        }
        #saved-total-score-display { /* Style for saved total score */
            font-size: 1rem; /* Adjust font size to fit in h2 */
            font-weight: 600;
            color: #cbd5e0;
            margin-left: 8px; /* Space from the main title text */
        }

        /* Hamburger Menu Styles */
        #hamburger-button {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1001; /* Above side menu */
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 10px;
            border-radius: 8px;
            transition: background-color 0.2s;
        }
        #hamburger-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        #hamburger-button svg {
            width: 30px;
            height: 30px;
            fill: #e2e8f0; /* White color */
        }

        /* Override Bootstrap's offcanvas default background and text color */
        .offcanvas {
            background-color: #2d3748 !important; /* Darker gray background */
            color: #e2e8f0 !important; /* Light text */
        }
        .offcanvas-header {
            border-bottom: 1px solid #4a5568; /* Subtle border */
        }
        .offcanvas-title {
            color: #63b3ed !important; /* Blue title */
            font-weight: 700;
        }
        .btn-close {
            filter: invert(1) grayscale(1) brightness(2); /* Make close button white */
        }

        .menu-item { /* Unified style for menu items */
            width: 100%;
            padding: 12px 15px;
            border-radius: 8px;
            background-color: #4a5568;
            color: white;
            font-weight: 600;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            border: none; /* Ensure no default button borders */
        }
        .menu-item:hover {
            background-color: #3182ce;
        }
        .menu-section-hidden {
            display: none !important;
        }

        /* No need for custom overlay as Bootstrap handles backdrop */
        /* #overlay { ... } */


        /* Responsive adjustments */
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            .player-hand {
                flex-wrap: wrap;
                justify-content: center;
                margin-bottom: 20px;
            }
            .card {
                width: 80px;
                height: 120px;
                margin: 5px;
            }
            .deck-card {
                margin-left: 0;
                margin-top: 10px;
            }
            .controls {
                flex-direction: column;
                gap: 15px;
                width: 100%;
            }
            .game-button {
                width: 100%;
            }
            .header-area {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            .header-area h1 {
                text-align: center; /* Center title on small screens */
            }
            .left-header-content {
                align-items: center; /* Center content on small screens */
                order: 1; /* Title and info first */
            }
            .game-info {
                align-items: center; /* Center text on small screens */
            }
            #high-score-list {
                max-width: 90%; /* Adjust width for small screens */
                max-height: 150px; /* Adjust height for small screens */
                order: 3; /* Place it below title and deck on small screens for better flow */
            }
            .deck-area {
                order: 2; /* Place deck below title but before high score on small screens */
                align-items: center; /* Center deck info on small screens */
                text-align: center;
            }
            #hamburger-button {
                top: 10px;
                left: 10px;
            }
        }
    </style>
</head>
<body class="flex items-center justify-center min-height-screen bg-gray-900 text-gray-100 p-5">

    <div class="game-wrapper">
        <!-- Hamburger Button -->
        <button id="hamburger-button" class="btn btn-dark p-2 rounded-lg" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasMenu" aria-controls="offcanvasMenu">
            <svg viewBox="0 0 100 80" width="30" height="30">
                <rect width="100" height="15" rx="8" fill="#e2e8f0"></rect>
                <rect y="30" width="100" height="15" rx="8" fill="#e2e8f0"></rect>
                <rect y="60" width="100" height="15" rx="8" fill="#e2e8f0"></rect>
            </svg>
        </button>

        <!-- Side Menu (Offcanvas) -->
        <div class="offcanvas offcanvas-start text-bg-dark" tabindex="-1" id="offcanvasMenu" aria-labelledby="offcanvasMenuLabel">
            <div class="offcanvas-header">
                <h5 class="offcanvas-title" id="offcanvasMenuLabel">Menu</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Close"></button>
            </div>
            <div class="offcanvas-body d-flex flex-column gap-3">
                <div id="main-menu-options" class="d-flex flex-column gap-3">
                    <button id="toggle-sound-button" class="menu-item">üîä Sound On</button>
                    <button id="help-button" class="menu-item">‚ùì Help</button>
                    <button id="lang-menu-button" class="menu-item">üåê Language</button>
                </div>

                <div id="language-options" class="d-flex flex-column gap-3 menu-section-hidden">
                    <button id="back-button" class="menu-item">‚¨ÖÔ∏è Back</button>
                    <button id="lang-sv-button" class="menu-item">Svenska üá∏üá™</button>
                    <button id="lang-en-button" class="menu-item">English üá¨üáß</button>
                </div>
            </div>
        </div>

        <div class="game-container">
            <div class="header-area">
                <div class="left-header-content">
                    <h1 class="text-4xl font-bold text-blue-400" id="game-title">‚ô†Ô∏è Single Player Poker</h1>
                    <div class="game-info">
                        <div class="text-xl font-semibold" id="draw-count-label">Draws left: <span id="draw-count" class="text-blue-300">3</span></div>
                        <div class="text-xl font-semibold" id="hand-result-label">Best hand: <span id="hand-result" class="text-green-300"></span></div>
                    </div>
                </div>
                <!-- High Score List moved here -->
                <div id="high-score-list" class="high-score-list">
                    <h2 id="high-score-title">üèÜ <span id="high-score-title-text">High Score</span> <span id="saved-total-score-display"></span></h2>
                    <ul id="score-list-items">
                        <!-- Scores will be loaded here with JavaScript -->
                    </ul>
                    <div id="total-score" class="text-xl font-bold">Total Score: 0</div>
                </div>
                <div class="deck-area">
                    <div id="deck" class="deck-card flex-shrink-0">
                        <span class="text-5xl">üÉè</span>
                    </div>
                    <div class="text-lg font-medium text-gray-400" id="remaining-cards-label">Cards left: <span id="remaining-cards">52</span></div>
                </div>
            </div>

            <div id="player-hand" class="player-hand flex justify-center flex-wrap gap-4 mb-8">
                <!-- Cards will be loaded here with JavaScript -->
            </div>

            <div class="controls flex flex-col md:flex-row gap-4 w-full justify-center">
                <button id="draw-button" class="game-button">üîÑ Discard selected cards</button>
                <button id="stand-button" class="game-button bg-green-600 hover:bg-green-700">‚úã Stand</button>
                <button id="continue-game-button" class="game-button bg-yellow-600 hover:bg-yellow-700">‚ñ∂Ô∏è Continue Game</button>
                <button id="new-game-button" class="game-button bg-purple-600 hover:bg-purple-700 hidden">‚ú® New Game</button>
            </div>
        </div>
    </div>

    <!-- Message box for warnings/information -->
    <div id="message-box" class="message-box">
        <p id="message-text" class="text-lg font-medium"></p>
        <button id="message-ok-button">OK</button>
    </div>

    <!-- Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" xintegrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <!-- Tone.js for sound generation (moved to end of body) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js" crossorigin="anonymous"></script>

    <script>
        // Cookie functions
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        function eraseCookie(name) {
            document.cookie = name + '=; Max-Age=-99999999;';
        }

        // Function to show message box
        function showMessageBox(message) {
            const messageBox = document.getElementById('message-box');
            const messageText = document.getElementById('message-text');
            const messageOkButton = document.getElementById('message-ok-button');

            messageText.textContent = message;
            messageBox.style.display = 'flex'; // Show message box

            messageOkButton.onclick = () => {
                messageBox.style.display = 'none'; // Hide message box when OK is clicked
            };
        }

        // Card Class
        class Card {
            constructor(suit, rank) {
                this.suit = suit; // Suit: 'H' (Hearts), 'D' (Diamonds), 'C' (Clubs), 'S' (Spades)
                this.rank = rank; // Rank: '2', '3', ..., '10', 'J', 'Q', 'K', 'A'
            }

            // Returns a string representation of the card (e.g., "A‚ô†")
            toString() {
                return `${this.rank}${this.getSuitSymbol()}`;
            }

            // Returns the symbol for the suit
            getSuitSymbol() {
                switch (this.suit) {
                    case 'H': return '‚ô•';
                    case 'D': return '‚ô¶';
                    case 'C': return '‚ô£';
                    case 'S': return '‚ô†';
                    default: return '';
                }
            }

            // Checks if the card is red (Hearts or Diamonds)
            isRed() {
                return this.suit === 'H' || this.suit === 'D';
            }
        }

        // Deck Class
        class Deck {
            constructor() {
                this.cards = [];
                this.resetCardsOnly(); // Fill the deck with cards in order
                this.shuffle(); // Shuffle the deck immediately after filling
            }

            // Shuffles the deck using the Fisher-Yates algorithm
            shuffle() {
                for (let i = this.cards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]]; // Swap places
                }
            }

            // Creates a standard 52-card deck WITHOUT shuffling it
            resetCardsOnly() {
                const suits = ['H', 'D', 'C', 'S'];
                const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
                this.cards = []; // Ensure the deck is empty before filling
                for (const suit of suits) {
                    for (const rank of ranks) {
                        this.cards.push(new Card(suit, rank));
                    }
                }
            }

            // Resets the deck completely (fills and shuffles)
            reset() {
                this.resetCardsOnly();
                this.shuffle();
            }

            // Draws a card from the top of the deck
            draw() {
                if (this.cards.length === 0) {
                    showMessageBox(game.texts[game.currentLanguage].deckEmptyMessage);
                    return null;
                }
                return this.cards.pop();
            }

            // Returns the number of cards left in the deck
            remaining() {
                return this.cards.length;
            }
        }

        // Tone.js synth for card dealing sound
        let cardDealSynth; // Declare globally but initialize in startAudioContext

        let lastCardDealSoundTime = 0;
        const cardDealSoundCooldown = 0.3; // Increased cooldown to 300ms to match longer sound

        // Function to play card dealing sound
        async function playCardDealSound() {
            if (game.isSoundEnabled) {
                // Ensure audio context is running and synth is initialized
                if (Tone.context.state !== 'running') {
                    try {
                        await Tone.start();
                        console.log("Audio context started successfully from playCardDealSound.");
                    } catch (e) {
                        console.error("Error starting audio context from playCardDealSound:", e);
                        return; // Abort if context could not be started
                    }
                }
                // Initialize synth only once after context is running
                if (!cardDealSynth) {
                    cardDealSynth = new Tone.NoiseSynth({
                        noise: { type: "white" },
                        envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.15 },
                        filter: { type: "bandpass", frequency: 1500, Q: 0.8 }
                    }).toDestination();
                }

                const now = Tone.now();
                if (now - lastCardDealSoundTime > cardDealSoundCooldown) {
                    console.log("Playing card deal sound at:", now); // Debugging log
                    cardDealSynth.triggerAttackRelease("0.2", now); // Increased duration to 0.2 seconds
                    lastCardDealSoundTime = now;
                } else {
                    console.log("Card deal sound skipped due to cooldown."); // Debugging log
                }
            } else {
                console.log("Card deal sound not played. Enabled:", game.isSoundEnabled, "Context state:", Tone.context.state); // Debugging log
            }
        }

        // Text content for different languages
        const texts = {
            en: {
                gameTitle: "‚ô†Ô∏è Single Player Poker", // Updated title
                drawsLeft: "Draws left:",
                bestHand: "Best hand:",
                discardButton: "üîÑ Discard selected cards",
                standButton: "‚úã Stand",
                continueButton: "‚ñ∂Ô∏è Continue Game",
                newGameButton: "‚ú® New Game",
                soundOn: "üîä Sound On",
                soundOff: "üîá Sound Off",
                cardsLeft: "Cards left:",
                highScoreTitle: "High Score", // Changed to just text, emoji is in HTML
                savedTotalScore: "Saved Total Score:", // New text
                handLabel: "Hand",
                pointsLabel: "Points:",
                totalScore: "Total Score:",
                deckEmptyMessage: "The deck is empty!",
                selectCardsMessage: "Select at least one card to discard.",
                couldNotDiscardMessage: "The deck is empty, could not discard all cards.",
                allDrawsUsedMessage: (totalScore) => `Cards are out! Game over. üéâ Your total score: ${totalScore}`,
                gameOverMessage: (totalScore) => `Game over. üéâ Your total score: ${totalScore}`,
                standMessage: "You chose to stand. Your final hand is displayed.",
                menuTitle: "Menu",
                helpButton: "‚ùì Help", // New text for help button
                helpDescription: `
                    Welcome to Single Player Poker!
                    
                    The goal is to get the best possible poker hand.
                    
                    How to Play:
                    1.  You start with 5 cards.
                    2.  Click on the cards you want to discard (they will be highlighted).
                    3.  Click "Discard selected cards" to get new cards from the deck.
                    4.  You have 3 draws per game.
                    5.  You can "Stand" at any time to end your current hand.
                    6.  When a hand ends (after 3 draws or you stand), your hand's score is added to the High Score list.
                    7.  Click "Continue Game" to deal a new hand from the remaining cards in the deck.
                    8.  The game ends when there are not enough cards left to deal a full hand (5 cards).
                    9.  Your total score is saved and displayed.
                    
                    Poker Hand Ranks (Highest to Lowest):
                    - Royal Straight Flush (10)
                    - Straight Flush (9)
                    - Four of a Kind (8)
                    - Full House (7)
                    - Flush (6)
                    - Straight (5)
                    - Three of a Kind (4)
                    - Two Pair (3)
                    - One Pair (2)
                    - High Card (1)
                    
                    Good luck!
                `,
                langMenuTitle: "üåê Language", // New text for language menu title
                backButton: "Back" // Text for back button
            },
            sv: {
                gameTitle: "‚ô†Ô∏è Single Player Poker", // Updated title
                drawsLeft: "Drag kvar:",
                bestHand: "B√§sta hand:",
                discardButton: "üîÑ Byt valda kort",
                standButton: "‚úã Stanna",
                continueButton: "‚ñ∂Ô∏è Forts√§tt Spel",
                newGameButton: "‚ú® Nytt Spel",
                soundOn: "üîä Ljud P√•",
                soundOff: "üîá Ljud Av",
                cardsLeft: "Kort kvar:",
                highScoreTitle: "High Score", // Changed to just text, emoji is in HTML
                savedTotalScore: "Sparad total po√§ng:", // New text
                handLabel: "Hand",
                pointsLabel: "Po√§ng:",
                totalScore: "Total Po√§ng:",
                deckEmptyMessage: "Kortleken √§r tom!",
                selectCardsMessage: "V√§lj minst ett kort att byta ut.",
                couldNotDiscardMessage: "Kortleken √§r tom, kunde inte byta alla kort.",
                allDrawsUsedMessage: (totalScore) => `Korten √§r slut! Spelet √§r √∂ver. üéâ Din totala po√§ng: ${totalScore}`,
                gameOverMessage: (totalScore) => `Spelet √§r √∂ver. üéâ Din totala po√§ng: ${totalScore}`,
                standMessage: "Du valde att stanna. Din slutgiltiga hand visas.",
                menuTitle: "Meny",
                helpButton: "‚ùì Hj√§lp", // New text for help button
                helpDescription: `
                    V√§lkommen till Single Player Poker!
                    
                    M√•let √§r att f√• den b√§sta m√∂jliga pokerhanden.
                    
                    S√• h√§r spelar du:
                    1.  Du b√∂rjar med 5 kort.
                    2.  Klicka p√• de kort du vill g√∂ra dig av med (de markeras).
                    3.  Klicka p√• "Byt valda kort" f√∂r att f√• nya kort fr√•n h√∂gen.
                    4.  Du f√•r g√∂ra 3 drag per spel.
                    5.  Du kan "Stanna" n√§r som helst f√∂r att avsluta din nuvarande hand.
                    6.  N√§r en hand √§r slut (efter 3 drag eller du stannar), l√§ggs din hands po√§ng till i High Score-listan.
                    7.  Klicka p√• "Forts√§tt Spel" f√∂r att f√• en ny hand fr√•n de √•terst√•ende korten i h√∂gen.
                    8.  Spelet √§r slut n√§r det inte finns tillr√§ckligt med kort kvar f√∂r att dela ut en full hand (5 kort).
                    9.  Din totala po√§ng sparas och visas.
                    
                    Pokerhandrankning (h√∂gst till l√§gst):
                    - Royal Straight Flush (10)
                    - Straight Flush (9)
                    - Fyrtal (8)
                    - K√•k (Full House) (7)
                    - F√§rg (Flush) (6)
                    - Stege (Straight) (5)
                    - Triss (Three of a Kind) (4)
                    - Tv√•par (Two Pair) (3)
                    - Par (One Pair) (2)
                    - H√∂gt Kort (High Card) (1)
                    
                    Lycka till!
                `,
                langMenuTitle: "üåê Spr√•k", // New text for language menu title
                backButton: "Tillbaka" // Text for back button
            }
        };


        // Main game object
        const game = {
            deck: null,
            playerHand: [],
            drawsRemaining: 3,
            maxDraws: 3, // Max number of draws
            isGameOver: false,
            scores: [], // New array to store scores for each hand
            isSoundEnabled: true, // Sound on by default
            currentLanguage: 'en', // Default language is English
            texts: texts, // Reference to the language object

            // DOM Elements - Initialized in initializeDOMElements
            gameTitleEl: null,
            drawCountLabelEl: null,
            drawCountEl: null,
            handResultLabelEl: null,
            handResultEl: null,
            drawButton: null,
            standButton: null,
            continueButton: null,
            newGameButton: null,
            toggleSoundButton: null,
            helpButton: null, // New help button DOM element
            remainingCardsLabelEl: null,
            remainingCardsEl: null,
            highScoreTitleEl: null,
            highScoreTitleTextEl: null, // Added for the text part of the H2
            savedTotalScoreDisplayEl: null, // The span inside H2 for saved score
            scoreListItemsEl: null,
            totalScoreEl: null,
            menuTitleEl: null,
            langSvButton: null,
            langEnButton: null,
            mainMenuOptionsEl: null, // Reference to the main menu options container
            languageOptionsEl: null, // Reference to the language options container
            langMenuButton: null, // Reference to the Language menu button
            backButton: null, // Reference to the Back button in language menu

            // New method to initialize DOM elements
            initializeDOMElements() {
                this.gameTitleEl = document.getElementById('game-title');
                this.drawCountLabelEl = document.getElementById('draw-count-label');
                this.drawCountEl = this.drawCountLabelEl ? this.drawCountLabelEl.querySelector('#draw-count') : null;
                this.handResultLabelEl = document.getElementById('hand-result-label');
                this.handResultEl = this.handResultLabelEl ? this.handResultLabelEl.querySelector('#hand-result') : null;

                this.drawButton = document.getElementById('draw-button');
                this.standButton = document.getElementById('stand-button');
                this.continueButton = document.getElementById('continue-game-button');
                this.newGameButton = document.getElementById('new-game-button');
                this.toggleSoundButton = document.getElementById('toggle-sound-button');
                this.helpButton = document.getElementById('help-button'); // Initialize new button
                this.remainingCardsLabelEl = document.getElementById('remaining-cards-label');
                this.remainingCardsEl = this.remainingCardsLabelEl ? this.remainingCardsLabelEl.querySelector('#remaining-cards') : null;
                
                this.highScoreListEl = document.getElementById('high-score-list');
                this.highScoreTitleEl = document.getElementById('high-score-title'); // Parent of high-score-title-text and saved-total-score-display
                this.highScoreTitleTextEl = document.getElementById('high-score-title-text'); // Get the span for the text
                this.savedTotalScoreDisplayEl = document.getElementById('saved-total-score-display'); // Get the span for saved score

                this.scoreListItemsEl = document.getElementById('score-list-items');
                this.totalScoreEl = document.getElementById('total-score');
                this.menuTitleEl = document.getElementById('offcanvasMenuLabel'); // Bootstrap offcanvas title
                this.langSvButton = document.getElementById('lang-sv-button');
                this.langEnButton = document.getElementById('lang-en-button');
                this.playerHandEl = document.getElementById('player-hand');

                // New menu element references
                this.mainMenuOptionsEl = document.getElementById('main-menu-options');
                this.languageOptionsEl = document.getElementById('language-options');
                this.langMenuButton = document.getElementById('lang-menu-button');
                this.backButton = document.getElementById('back-button');
            },

            // Helper function to create a card DOM element
            createCardElement(card, index) {
                const cardEl = document.createElement('div');
                cardEl.classList.add('card', 'rounded-xl', 'flex', 'flex-col', 'justify-between', 'items-center', 'p-2', 'shadow-lg', 'transition-all', 'duration-200');
                if (card.isRed()) {
                    cardEl.classList.add('red');
                }
                cardEl.dataset.index = index; // Store index to know which card was selected

                cardEl.innerHTML = `
                    <div class="card-top-left">${card.rank}${card.getSuitSymbol()}</div>
                    <div class="card-rank">${card.rank}</div>
                    <div class="card-suit">${card.getSuitSymbol()}</div>
                    <div class="card-bottom-right">${card.rank}${card.getSuitSymbol()}</div>
                `;
                cardEl.addEventListener('click', () => this.toggleCardSelection(cardEl));
                return cardEl;
            },

            // Sets the language of the game UI
            setLanguage(lang) {
                this.currentLanguage = lang;
                const t = this.texts[lang];

                if (this.gameTitleEl) {
                    this.gameTitleEl.textContent = t.gameTitle;
                } else {
                    console.error("Error: gameTitleEl is null. Cannot set game title. Re-initializing and trying again.");
                    this.gameTitleEl = document.getElementById('game-title');
                    if (this.gameTitleEl) {
                         this.gameTitleEl.textContent = t.gameTitle;
                    }
                }
                
                if (this.drawCountLabelEl) {
                    this.drawCountLabelEl.innerHTML = `${t.drawsLeft} <span id="draw-count" class="text-blue-300"></span>`;
                    this.drawCountEl = document.getElementById('draw-count'); // Re-get reference
                    if (this.drawCountEl) this.drawCountEl.textContent = this.drawsRemaining;
                } else {
                    console.error("Error: drawCountLabelEl is null. Cannot set draws left label.");
                    this.drawCountLabelEl = document.getElementById('draw-count-label');
                    if (this.drawCountLabelEl) {
                        this.drawCountLabelEl.innerHTML = `${t.drawsLeft} <span id="draw-count" class="text-blue-300"></span>`;
                        this.drawCountEl = document.getElementById('draw-count');
                        if (this.drawCountEl) this.drawCountEl.textContent = this.drawsRemaining;
                    }
                }

                if (this.handResultLabelEl) {
                    this.handResultLabelEl.innerHTML = `${t.bestHand} <span id="hand-result" class="text-green-300"></span>`;
                    this.handResultEl = document.getElementById('hand-result'); // Re-get reference
                    if (this.handResultEl) this.handResultEl.textContent = this.evaluateHand(this.playerHand).name;
                } else {
                    console.error("Error: handResultLabelEl is null. Cannot set best hand label.");
                    this.handResultLabelEl = document.getElementById('hand-result-label');
                    if (this.handResultLabelEl) {
                        this.handResultLabelEl.innerHTML = `${t.bestHand} <span id="hand-result" class="text-green-300"></span>`;
                        this.handResultEl = document.getElementById('hand-result');
                        if (this.handResultEl) this.handResultEl.textContent = this.evaluateHand(this.playerHand).name;
                    }
                }

                if (this.drawButton) this.drawButton.textContent = t.discardButton;
                if (this.standButton) this.standButton.textContent = t.standButton;
                if (this.continueButton) this.continueButton.textContent = t.continueButton;
                if (this.newGameButton) this.newGameButton.textContent = t.newGameButton;
                if (this.toggleSoundButton) this.toggleSoundButton.textContent = this.isSoundEnabled ? t.soundOn : t.soundOff;
                if (this.helpButton) this.helpButton.textContent = t.helpButton; // Set text for new help button
                if (this.langMenuButton) this.langMenuButton.textContent = t.langMenuTitle; // Set text for language menu button
                
                if (this.remainingCardsLabelEl) {
                    this.remainingCardsLabelEl.innerHTML = `${t.cardsLeft} <span id="remaining-cards"></span>`;
                    this.remainingCardsEl = document.getElementById('remaining-cards'); // Re-get reference
                    if (this.remainingCardsEl) this.remainingCardsEl.textContent = this.deck ? this.deck.remaining() : 52;
                } else {
                    console.error("Error: remainingCardsLabelEl is null. Cannot set cards left label.");
                    this.remainingCardsLabelEl = document.getElementById('remaining-cards-label');
                    if (this.remainingCardsLabelEl) {
                        this.remainingCardsLabelEl.innerHTML = `${t.cardsLeft} <span id="remaining-cards"></span>`;
                        this.remainingCardsEl = document.getElementById('remaining-cards');
                        if (this.remainingCardsEl) this.remainingCardsEl.textContent = this.deck ? this.deck.remaining() : 52;
                    }
                }

                // Update High Score title text
                if (this.highScoreTitleTextEl) {
                    this.highScoreTitleTextEl.textContent = t.highScoreTitle;
                } else {
                    console.error("Error: highScoreTitleTextEl is null. Cannot set high score title text.");
                    this.highScoreTitleTextEl = document.getElementById('high-score-title-text');
                    if (this.highScoreTitleTextEl) this.highScoreTitleTextEl.textContent = t.highScoreTitle;
                }

                if (this.menuTitleEl) this.menuTitleEl.textContent = t.menuTitle; // Update offcanvas title
                if (this.langSvButton) this.langSvButton.textContent = `${t.langSwedish} üá∏üá™`;
                if (this.langEnButton) this.langEnButton.textContent = `${t.langEnglish} üá¨üáß`;
                if (this.backButton) this.backButton.textContent = `‚¨ÖÔ∏è ${t.backButton}`;

                // Update saved total score display
                if (this.savedTotalScoreDisplayEl) {
                    const savedScore = getCookie('pokerTotalScore');
                    this.savedTotalScoreDisplayEl.textContent = savedScore ? `(${savedScore}p)` : ''; // Format (XXp)
                } else {
                    console.error("Error: savedTotalScoreDisplayEl is null. Cannot set saved total score.");
                    this.savedTotalScoreDisplayEl = document.getElementById('saved-total-score-display');
                    if (this.savedTotalScoreDisplayEl) {
                        const savedScore = getCookie('pokerTotalScore');
                        this.savedTotalScoreDisplayEl.textContent = savedScore ? `(${savedScore}p)` : '';
                    }
                }


                // Re-render high score list and total score to update labels
                this.renderHighScoreList();
            },

            // Shows the main menu options
            showMainMenu() {
                if (this.mainMenuOptionsEl) this.mainMenuOptionsEl.classList.remove('menu-section-hidden');
                if (this.languageOptionsEl) this.languageOptionsEl.classList.add('menu-section-hidden');
                if (this.menuTitleEl) this.menuTitleEl.textContent = this.texts[this.currentLanguage].menuTitle; // Set offcanvas title
            },

            // Shows the language selection options
            showLanguageOptions() {
                if (this.mainMenuOptionsEl) this.mainMenuOptionsEl.classList.add('menu-section-hidden');
                if (this.languageOptionsEl) this.languageOptionsEl.classList.remove('menu-section-hidden');
                if (this.menuTitleEl) this.menuTitleEl.textContent = this.texts[this.currentLanguage].langMenuTitle; // Set offcanvas title to Language/Spr√•k
            },

            // Starts a new game
            startGame() {
                this.initializeDOMElements(); // Call this first to ensure elements are ready
                this.deck = new Deck();
                this.scores = []; // Clear scores from previous game
                this.isGameOver = false;

                this.dealNewRound(); // Start the first round
                this.setLanguage(this.currentLanguage); // Set language on start
                this.showMainMenu(); // Ensure main menu is visible on game start
            },

            // Deals a new hand for a new round
            dealNewRound() {
                // Check if there are enough cards for a new hand
                if (this.deck.remaining() < 5) {
                    this.endGame(true); // Game over if cards run out
                    return;
                }

                this.playerHand = [];
                this.drawsRemaining = this.maxDraws;

                // Show game buttons, hide continue/new game
                if (this.drawButton) this.drawButton.classList.remove('hidden');
                if (this.standButton) this.standButton.classList.remove('hidden');
                if (this.newGameButton) this.newGameButton.classList.add('hidden');
                
                // Forts√§tt-knappen √§r alltid synlig men inaktiveras vid ny runda
                if (this.continueButton) this.continueButton.disabled = true; 

                if (this.drawButton) this.drawButton.disabled = false;
                if (this.standButton) this.standButton.disabled = false;

                for (let i = 0; i < 5; i++) {
                    const card = this.deck.draw();
                    if (card) {
                        this.playerHand.push(card);
                    }
                }
                this.updateUI();
                playCardDealSound(); // Play sound when new hand is dealt
            },

            // Updates the UI
            updateUI() {
                // Only render hand if not in the middle of card animation
                if (!this.isAnimatingCards) {
                    this.renderHand();
                }
                if (this.drawCountEl) this.drawCountEl.textContent = this.drawsRemaining;
                if (this.remainingCardsEl) this.remainingCardsEl.textContent = this.deck.remaining();
                const handEvaluation = this.evaluateHand(this.playerHand);
                if (this.handResultEl) this.handResultEl.textContent = handEvaluation.name;

                // Handle button states
                if (this.isGameOver) {
                    if (this.drawButton) this.drawButton.disabled = true;
                    if (this.standButton) this.standButton.disabled = true;
                    if (this.continueButton) this.continueButton.disabled = true; // Disable continue when game is completely over
                    if (this.newGameButton) this.newGameButton.classList.remove('hidden'); // Show New Game button
                } else if (this.drawsRemaining === 0) {
                    if (this.drawButton) this.drawButton.disabled = true; // No more draws in this hand
                    if (this.standButton) this.standButton.disabled = true; // Cannot stand if draws are out
                    if (this.continueButton) this.continueButton.disabled = false; // Enable continue when round is over
                    if (this.newGameButton) this.newGameButton.classList.add('hidden');
                } else {
                    if (this.drawButton) this.drawButton.disabled = false;
                    if (this.standButton) this.standButton.disabled = false;
                    if (this.continueButton) this.continueButton.disabled = true; // Inaktivera forts√§tt under p√•g√•ende runda
                    if (this.newGameButton) this.newGameButton.classList.add('hidden');
                }
            },

            // Renders the player's hand in the DOM
            renderHand() {
                if (this.playerHandEl) { // Add check for playerHandEl
                    this.playerHandEl.innerHTML = ''; // Clear existing cards
                    this.playerHand.forEach((card, index) => {
                        const cardEl = this.createCardElement(card, index);
                        this.playerHandEl.appendChild(cardEl);
                    });
                }
            },

            // Toggles card selection
            toggleCardSelection(cardEl) {
                if (this.isGameOver || this.drawsRemaining === 0) return; // Cannot select cards if game is over or no draws left
                cardEl.classList.toggle('selected');
            },

            // Handles card exchange with animations
            async handleDraw() {
                if (this.drawsRemaining === 0) {
                    return; // Abort if no draws left
                }

                const selectedCards = Array.from(this.playerHandEl.children).filter(cardEl =>
                    cardEl.classList.contains('selected')
                );

                if (selectedCards.length === 0) {
                    showMessageBox(this.texts[this.currentLanguage].selectCardsMessage);
                    return;
                }

                if (this.drawButton) this.drawButton.disabled = true; // Disable buttons during animation
                if (this.standButton) this.standButton.disabled = true;
                if (this.continueButton) this.continueButton.disabled = true; // Disable continue during animation
                this.isAnimatingCards = true; // Mark that animation is in progress

                let cardsReplacedCount = 0;
                const animationDelay = 300; // Matches CSS animation duration

                // Animate out selected cards first
                const exitPromises = selectedCards.map(cardEl => {
                    return new Promise(resolve => {
                        cardEl.classList.add('card-exit');
                        setTimeout(() => {
                            cardEl.remove(); // Remove card from DOM after exit animation
                            resolve();
                        }, animationDelay);
                    });
                });

                await Promise.all(exitPromises); // Wait until all exit animations are complete

                // Play sound when cards are exchanged
                playCardDealSound();

                // Replace cards and animate in new ones
                const entryPromises = [];
                for (const cardEl of selectedCards) {
                    const indexToReplace = parseInt(cardEl.dataset.index);
                    const newCard = this.deck.draw();

                    if (newCard) {
                        this.playerHand[indexToReplace] = newCard;
                        const newCardEl = this.createCardElement(newCard, indexToReplace);
                        newCardEl.classList.add('card-enter'); // Add entry animation
                        
                        // Find the correct position to insert the new card
                        const referenceNode = this.playerHandEl.children[indexToReplace];
                        if (referenceNode) {
                            this.playerHandEl.insertBefore(newCardEl, referenceNode);
                        } else {
                            this.playerHandEl.appendChild(newCardEl);
                        }

                        entryPromises.push(new Promise(resolve => {
                            setTimeout(() => {
                                newCardEl.classList.remove('card-enter');
                                resolve();
                            }, animationDelay);
                        }));
                        cardsReplacedCount++;
                    } else {
                        showMessageBox(this.texts[this.currentLanguage].couldNotDiscardMessage);
                        this.isGameOver = true; // Game is over if deck is empty
                        break; // Abort if deck is empty
                    }
                }

                await Promise.all(entryPromises); // Wait until all entry animations are complete

                this.isAnimatingCards = false; // Animation complete

                if (cardsReplacedCount > 0) {
                    this.drawsRemaining--;
                }

                this.updateUI(); // Update UI after animations and card exchanges

                if (this.drawsRemaining === 0 || this.isGameOver) {
                    this.endHand(); // End the hand when draws are out or game is over
                }
            },

            // Handles player choosing to stand
            handleStand() {
                this.endHand(); // End the hand
            },

            // Ends the current hand
            endHand() {
                // Save the score for the current hand
                const handEvaluation = this.evaluateHand(this.playerHand);
                this.scores.push(handEvaluation); // Save the entire object
                this.drawsRemaining = 0; // Set draws left to 0 to activate "Continue Game" button
                this.updateUI(); // Update UI to show buttons correctly
                this.renderHighScoreList(); // Update high score list after each hand

                // Check if there are enough cards for the next round
                if (this.deck.remaining() < 5) {
                    this.endGame(true); // Game is completely over
                }
            },

            // Ends the entire game (when the deck is empty)
            endGame(deckEmpty = false) {
                this.isGameOver = true;
                this.updateUI(); // Update UI to show New Game button and hide others

                let finalMessage = "";
                let totalScore = this.scores.reduce((sum, hand) => sum + hand.score, 0);

                // Save total score to cookie
                setCookie('pokerTotalScore', totalScore, 365); // Save for 365 days

                if (deckEmpty) {
                    finalMessage = this.texts[this.currentLanguage].allDrawsUsedMessage(totalScore);
                } else {
                    finalMessage = this.texts[this.currentLanguage].gameOverMessage(totalScore);
                }
                showMessageBox(finalMessage);
                // High score list is already visible and updated
            },

            // Function to evaluate the poker hand and return name + score
            evaluateHand(hand) {
                if (hand.length !== 5) return { name: "Invalid hand", score: 0 };

                const ranks = hand.map(card => card.rank);
                const suits = hand.map(card => card.suit);

                const rankValues = ranks.map(r => {
                    if (r === 'J') return 11;
                    if (r === 'Q') return 12;
                    if (r === 'K') return 13;
                    if (r === 'A') return 14;
                    return parseInt(r);
                }).sort((a, b) => a - b);

                const rankCounts = {};
                ranks.forEach(r => { rankCounts[r] = (rankCounts[r] || 0) + 1; });
                const suitCounts = {};
                suits.forEach(s => { suitCounts[s] = (suitCounts[s] || 0) + 1; });

                const numPairs = Object.values(rankCounts).filter(count => count === 2).length;
                const numThrees = Object.values(rankCounts).filter(count => count === 3).length;
                const numFours = Object.values(rankCounts).filter(count => count === 4).length;
                const isFlush = Object.values(suitCounts).some(count => count >= 5);

                let isStraight = true;
                // Handle Ace as low for straight (A, 2, 3, 4, 5)
                const lowAceRankValues = rankValues.includes(14) ? [...rankValues.filter(r => r !== 14), 1].sort((a, b) => a - b) : rankValues;

                for (let i = 0; i < lowAceRankValues.length - 1; i++) {
                    if (lowAceRankValues[i + 1] !== lowAceRankValues[i] + 1) {
                        isStraight = false;
                        break;
                    }
                }
                // If not a low ace straight, try normal straight
                if (!isStraight) {
                    isStraight = true;
                    for (let i = 0; i < rankValues.length - 1; i++) {
                        if (rankValues[i + 1] !== rankValues[i] + 1) {
                            isStraight = false;
                            break;
                        }
                        // Special case for Ace as highest card in straight (10, J, Q, K, A)
                        if (rankValues[i] === 10 && rankValues[i+1] === 11 && rankValues[i+2] === 12 && rankValues[i+3] === 13 && rankValues[i+4] === 14) {
                            isStraight = true;
                            break;
                        }
                    }
                }

                // Evaluate hand in descending order of strength
                if (isStraight && isFlush && (rankValues[4] === 14 && rankValues[0] === 10)) return { name: "Royal Straight Flush!", score: 10 };
                if (isStraight && isFlush) return { name: "Straight Flush", score: 9 };
                if (numFours === 1) return { name: "Four of a Kind", score: 8 };
                if (numThrees === 1 && numPairs === 1) return { name: "Full House", score: 7 };
                if (isFlush) return { name: "Flush", score: 6 };
                if (isStraight) return { name: "Straight", score: 5 };
                if (numThrees === 1) return { name: "Three of a Kind", score: 4 };
                if (numPairs === 2) return { name: "Two Pair", score: 3 };
                if (numPairs === 1) return { name: "One Pair", score: 2 };

                const highestRank = ranks[rankValues.length - 1];
                return { name: `High Card: ${highestRank}`, score: 1 };
            },

            // Renders the high score list
            renderHighScoreList() {
                if (this.scoreListItemsEl) { // Add check for scoreListItemsEl
                    this.scoreListItemsEl.innerHTML = ''; // Clear existing list items
                    let totalScore = 0;
                    // Iterate in reverse to show latest result at the top
                    for (let i = this.scores.length - 1; i >= 0; i--) {
                        const handResult = this.scores[i];
                        const listItem = document.createElement('li');
                        // Use original index for display (Hand 1, Hand 2, etc.)
                        listItem.innerHTML = `<span>${this.texts[this.currentLanguage].handLabel} ${i + 1}: ${handResult.name}</span> <span>${this.texts[this.currentLanguage].pointsLabel} ${handResult.score}</span>`;
                        this.scoreListItemsEl.appendChild(listItem);
                        totalScore += handResult.score;
                    }
                    if (this.totalScoreEl) { // Add check for totalScoreEl
                        this.totalScoreEl.textContent = `${this.texts[this.currentLanguage].totalScore} ${totalScore}`;
                    }
                }
                // Update saved total score display
                if (this.savedTotalScoreDisplayEl) { // Changed from savedTotalScoreEl to savedTotalScoreDisplayEl
                    const savedScore = getCookie('pokerTotalScore');
                    this.savedTotalScoreDisplayEl.textContent = savedScore ? `(${savedScore}p)` : '';
                }
            },

            // Toggles sound on/off
            toggleSound() {
                this.isSoundEnabled = !this.isSoundEnabled;
                if (this.toggleSoundButton) { // Add check for toggleSoundButton
                    this.toggleSoundButton.textContent = this.isSoundEnabled ? this.texts[this.currentLanguage].soundOn : this.texts[this.currentLanguage].soundOff;
                }
            }
        };

        // Event listeners for buttons
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Tone.js audio context on first user interaction
            let audioContextStarted = false;
            const startAudioContext = async () => {
                if (!audioContextStarted) {
                    try {
                        await Tone.start();
                        console.log("Audio context started successfully from initial click listener.");
                        audioContextStarted = true;
                    } catch (e) {
                        console.error("Error starting audio context from initial click listener:", e);
                    }
                }
            };

            // Call initializeDOMElements at the very beginning of DOMContentLoaded
            game.initializeDOMElements();

            // Attach startAudioContext to any button click, but only run once
            document.body.addEventListener('click', (event) => {
                if (event.target.tagName === 'BUTTON') {
                    startAudioContext();
                }
            }, { once: true });

            if (game.drawButton) game.drawButton.addEventListener('click', () => game.handleDraw());
            if (game.standButton) game.standButton.addEventListener('click', () => game.handleStand());
            if (game.continueButton) game.continueButton.addEventListener('click', () => game.dealNewRound());
            if (game.newGameButton) game.newGameButton.addEventListener('click', () => game.startGame());
            if (game.toggleSoundButton) game.toggleSoundButton.addEventListener('click', () => game.toggleSound()); // Event listener for sound button
            if (game.helpButton) game.helpButton.addEventListener('click', () => { // Event listener for help button
                showMessageBox(game.texts[game.currentLanguage].helpDescription);
                // Close menu after showing help
                const offcanvasMenu = bootstrap.Offcanvas.getInstance(document.getElementById('offcanvasMenu'));
                if (offcanvasMenu) offcanvasMenu.hide();
            });

            // Hamburger menu logic
            const hamburgerButton = document.getElementById('hamburger-button');
            const offcanvasMenuEl = document.getElementById('offcanvasMenu'); // Get the offcanvas element
            const closeMenuButton = offcanvasMenuEl ? offcanvasMenuEl.querySelector('.btn-close') : null; // Get Bootstrap's close button

            if (hamburgerButton) {
                hamburgerButton.addEventListener('click', () => {
                    // Bootstrap handles showing the offcanvas
                    game.showMainMenu(); // Show main menu options when opening hamburger
                });
            }

            if (closeMenuButton) {
                closeMenuButton.addEventListener('click', () => {
                    // Bootstrap handles hiding the offcanvas
                });
            }

            // Language menu navigation
            if (game.langMenuButton) {
                game.langMenuButton.addEventListener('click', () => {
                    game.showLanguageOptions();
                });
            }
            if (game.backButton) {
                game.backButton.addEventListener('click', () => {
                    game.showMainMenu();
                });
            }

            // Language selection listeners
            if (game.langSvButton) {
                game.langSvButton.addEventListener('click', () => {
                    game.setLanguage('sv');
                    // Hide offcanvas after language selection
                    const offcanvasMenu = bootstrap.Offcanvas.getInstance(document.getElementById('offcanvasMenu'));
                    if (offcanvasMenu) offcanvasMenu.hide();
                });
            }
            if (game.langEnButton) {
                game.langEnButton.addEventListener('click', () => {
                    game.setLanguage('en');
                    // Hide offcanvas after language selection
                    const offcanvasMenu = bootstrap.Offcanvas.getInstance(document.getElementById('offcanvasMenu'));
                    if (offcanvasMenu) offcanvasMenu.hide();
                });
            }

            // Start the game when the page loads
            game.startGame();
        });
    </script>
</body>
</html>
