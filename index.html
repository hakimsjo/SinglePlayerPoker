<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Single Player Poker Game</title>
    <!-- Bootstrap CSS CDN -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" xintegrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Tailwind CSS CDN for easy styling (still useful for some utility classes not in Bootstrap) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .game-wrapper { /* New wrapper to handle main layout */
            position: relative; /* For positioning hamburger button */
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 1000px;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
        }
        .game-container {
            background-color: #2d3748;
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
        }
        .header-area {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
            margin-bottom: 20px;
            gap: 20px;
        }
        .left-header-content {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            flex-shrink: 0;
        }
        .header-area h1 {
            flex-shrink: 0;
            text-align: left;
            margin-bottom: 8px;
        }
        .game-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
        }
        .player-hand-and-deck { /* New container for player hand and deck */
            display: flex;
            justify-content: center;
            align-items: center; /* Align items vertically in the center */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 16px; /* Space between cards and deck */
            margin-bottom: 32px;
            width: 100%; /* Take full width to manage internal layout */
        }
        .player-hand { /* Ensure cards are displayed in a row */
            display: flex;
            justify-content: center;
            flex-wrap: wrap; /* Allow cards to wrap on smaller screens */
            gap: 16px; /* Space between cards */
            /* Removed margin-bottom as it's now handled by player-hand-and-deck gap */
            flex-grow: 1; /* Allow player hand to take available space */
        }
        .card {
            width: 100px;
            height: 140px;
            background-color: #fff; /* Fallback: White background */
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 0 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            color: #2d3748 !important; /* Force dark text color for card content */
            position: relative;
            user-select: none;
        }
        .card.selected {
            transform: translateY(-15px) scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            border: 3px solid #63b3ed;
        }
        .card.red {
            color: #e53e3e !important; /* Force red color for hearts and diamonds */
        }
        .card-rank {
            font-size: 2.2rem;
            font-weight: 700;
        }
        .card-suit {
            font-size: 2rem;
        }
        .card-top-left, .card-bottom-right {
            position: absolute;
            font-size: 1.2rem;
            font-weight: 600;
        }
        .card-top-left {
            top: 5px;
            left: 8px;
        }
        .card-bottom-right {
            bottom: 5px;
            right: 8px;
            transform: rotate(180deg);
        }
        .deck-area {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
            text-align: right;
            flex-shrink: 0;
        }
        .deck-card {
            width: 100px;
            height: 140px;
            background-color: #4a5568;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            /* Adjust font-size for the joker emoji to fill the card */
            font-size: 8rem; /* Increased size significantly */
            line-height: 1; /* Adjust line-height to prevent extra space */
            color: #cbd5e0;
        }
        /* Custom button styling to override Bootstrap defaults */
        .game-button {
            padding: 12px 24px !important;
            border-radius: 10px !important;
            font-weight: 600 !important;
            cursor: pointer !important;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out !important;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
            border: none !important;
            background: linear-gradient(145deg, #4299e1, #3182ce) !important; /* Blue gradient */
            color: white !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 8px !important;
        }
        .game-button:hover {
            background: linear-gradient(145deg, #3182ce, #2c5282) !important;
            transform: translateY(-2px) !important;
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2) !important;
        }
        .game-button:active {
            transform: translateY(0) !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2) !important;
        }
        .game-button:disabled {
            background: #a0aec0 !important;
            cursor: not-allowed !important;
            box-shadow: none !important;
            transform: none !important;
        }
        /* Message box styling (now a Bootstrap Modal) */
        .modal-content { /* Removed .message-box prefix */
            background-color: #2d3748;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            color: #e2e8f0;
        }
        .modal-header { /* Removed .message-box prefix */
            border-bottom: none;
        }
        .modal-title { /* Removed .message-box prefix */
            color: #63b3ed;
            font-weight: 700;
        }
        .btn-close { /* Removed .message-box prefix */
            filter: invert(1) grayscale(1) brightness(2);
        }
        .modal-body { /* Removed .message-box prefix */
            font-size: 1.1rem;
        }
        .modal-footer { /* Removed .message-box prefix */
            border-top: none;
            justify-content: center;
        }
        .modal-footer .btn { /* Removed .message-box prefix */
            background-color: #4299e1;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .modal-footer .btn:hover { /* Removed .message-box prefix */
            background-color: #3182ce;
        }

        /* New CSS for animations */
        .card-exit {
            animation: cardExit 0.3s forwards ease-out;
        }

        .card-enter {
            animation: cardEnter 0.3s forwards ease-in;
            opacity: 0; /* Start invisible */
            transform: translateY(20px) scale(0.8); /* Start slightly below and smaller */
        }

        @keyframes cardExit {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px) scale(0.5) rotate(15deg);
                opacity: 0;
            }
        }

        @keyframes cardEnter {
            0% {
                transform: translateY(50px) scale(0.5) rotate(-15deg);
                opacity: 0;
            }
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        /* High Score List Styling */
        #high-score-list {
            background-color: #1a202c;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            flex-grow: 1;
            max-width: 300px;
            max-height: 180px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #high-score-list h2 {
            font-size: 1.4rem;
            font-weight: 700;
            color: #63b3ed;
            text-align: center;
            margin-bottom: 10px;
        }
        #high-score-list ul {
            list-style: none;
            padding: 0;
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 5px;
        }
        #high-score-list li {
            background-color: #2d3748;
            padding: 6px 10px;
            border-radius: 6px;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.95rem;
        }
        #high-score-list li:last-child {
            margin-bottom: 0;
        }
        #high-score-list li span:first-child {
            font-weight: 600;
            color: #e2e8f0;
        }
        #high-score-list li span:last-child {
            color: #90cdf4;
        }
        #total-score {
            font-size: 1.2rem;
            font-weight: 700;
            color: #a7f3d0;
            text-align: center;
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px solid #4a5568;
        }
        #saved-total-score-display {
            font-size: 1rem;
            font-weight: 600;
            color: #cbd5e0;
            margin-left: 8px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            .player-hand-and-deck { /* Stack vertically on small screens */
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }
            .player-hand {
                flex-wrap: wrap;
                justify-content: center;
                margin-bottom: 0; /* No extra margin when stacked */
            }
            .card {
                width: 80px;
                height: 120px;
                margin: 5px;
            }
            .deck-card {
                margin-left: 0;
                margin-top: 10px;
            }
            .controls {
                flex-direction: column;
                gap: 15px;
                width: 100%;
            }
            .game-button {
                width: 100%;
            }
            .header-area {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            .header-area h1 {
                text-align: center;
            }
            .left-header-content {
                align-items: center;
                order: 1;
            }
            .game-info {
                align-items: center;
            }
            #high-score-list {
                max-width: 90%;
                max-height: 150px;
                order: 3;
            }
            .deck-area {
                order: 2;
                align-items: center;
                text-align: center;
            }
        }
    </style>
</head>
<body class="d-flex justify-content-center align-items-center min-vh-100 bg-gray-900 text-gray-100 p-3">

    <div class="game-wrapper">
        <!-- Side Menu (Offcanvas - still included for Bootstrap's JS, but not used as a visible menu) -->
        <div class="offcanvas offcanvas-start text-bg-dark" tabindex="-1" id="offcanvasMenu" aria-labelledby="offcanvasMenuLabel">
            <div class="offcanvas-header">
                <h5 class="offcanvas-title" id="offcanvasMenuLabel">Menu</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Close"></button>
            </div>
            <div class="offcanvas-body d-flex flex-column gap-3">
                <!-- No menu items here, as they are now direct buttons -->
            </div>
        </div>

        <div class="game-container container p-4 rounded-3 shadow-lg">
            <div class="header-area d-flex justify-content-between align-items-start w-100 mb-4">
                <div class="left-header-content d-flex flex-column align-items-start flex-shrink-0">
                    <h1 class="text-4xl font-bold text-blue-400" id="game-title">‚ô†Ô∏è Single Player Poker</h1>
                    <div class="game-info d-flex flex-column align-items-start gap-1">
                        <div class="text-xl font-semibold" id="draw-count-label">Draws left: <span id="draw-count" class="text-blue-300">3</span></div>
                        <div class="text-xl font-semibold" id="hand-result-label">Best hand: <span id="hand-result" class="text-green-300"></span></div>
                    </div>
                </div>
                <!-- High Score List moved here -->
                <div id="high-score-list" class="high-score-list">
                    <h2 id="high-score-title">üèÜ <span id="high-score-title-text">High Score</span> <span id="saved-total-score-display"></span></h2>
                    <ul id="score-list-items" class="list-unstyled">
                        <!-- Scores will be loaded here with JavaScript -->
                    </ul>
                    <div id="total-score" class="text-xl font-bold text-green-300 text-center mt-3 pt-2 border-top border-secondary">Total Score: 0</div>
                </div>
            </div>

            <!-- Player hand and Deck on the same row -->
            <div class="player-hand-and-deck d-flex justify-content-center align-items-center flex-wrap gap-3 mb-4">
                <div id="player-hand" class="player-hand d-flex justify-content-center flex-wrap gap-3">
                    <!-- Cards will be loaded here with JavaScript -->
                </div>
                <div class="deck-area d-flex flex-column align-items-end gap-1 flex-shrink-0">
                    <div id="deck" class="deck-card flex-shrink-0">
                        <span class="text-5xl">üÉè</span>
                    </div>
                    <div class="text-lg font-medium text-gray-400" id="remaining-cards-label">Cards left: <span id="remaining-cards">52</span></div>
                </div>
            </div>


            <div class="controls d-flex flex-column flex-md-row gap-3 w-100 justify-content-center">
                <button id="draw-button" class="game-button btn btn-primary">üîÑ Discard selected cards</button>
                <button id="stand-button" class="game-button btn btn-success">‚úã Stand</button>
                <button id="continue-game-button" class="game-button btn btn-warning">‚ñ∂Ô∏è Continue Game</button>
                <button id="new-game-button" class="game-button btn btn-info hidden">‚ú® New Game</button>
            </div>
            
            <!-- New row for sound, help, and language buttons -->
            <div class="additional-controls d-flex flex-column flex-md-row gap-3 w-100 justify-content-center mt-3">
                <button id="toggle-sound-button" class="game-button btn btn-secondary">üîä Sound On</button>
                <button id="help-button" class="game-button btn btn-secondary">‚ùì Help</button>
                <button id="language-toggle-button" class="game-button btn btn-secondary">English üá¨üáß</button>
            </div>
        </div>
    </div>

    <!-- Message box (Bootstrap Modal) -->
    <div class="modal fade" id="messageBoxModal" tabindex="-1" aria-labelledby="messageBoxModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="messageBoxModalLabel">Game Message</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="messageBoxBody">
                    <!-- Message text goes here -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" xintegrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    
    <script>
        // Cookie functions
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        function eraseCookie(name) {
            document.cookie = name + '=; Max-Age=-99999999;';
        }

        // Function to show message box (now using Bootstrap Modal)
        function showMessageBox(message) {
            const messageBoxBody = document.getElementById('messageBoxBody');
            if (messageBoxBody) {
                messageBoxBody.innerHTML = message;
            }
            const messageBoxModal = new bootstrap.Modal(document.getElementById('messageBoxModal'));
            messageBoxModal.show();
        }

        // Card Class
        class Card {
            constructor(suit, rank) {
                this.suit = suit; // Suit: 'H' (Hearts), 'D' (Diamonds), 'C' (Clubs), 'S' (Spades)
                this.rank = rank; // Rank: '2', '3', ..., '10', 'J', 'Q', 'K', 'A'
            }

            // Returns a string representation of the card (e.g., "A‚ô†")
            toString() {
                return `${this.rank}${this.getSuitSymbol()}`;
            }

            // Returns the symbol for the suit
            getSuitSymbol() {
                switch (this.suit) {
                    case 'H': return '‚ô•';
                    case 'D': return '‚ô¶';
                    case 'C': return '‚ô£';
                    case 'S': return '‚ô†';
                    default: return '';
                }
            }

            // Checks if the card is red (Hearts or Diamonds)
            isRed() {
                return this.suit === 'H' || this.suit === 'D';
            }
        }

        // Deck Class
        class Deck {
            constructor() {
                this.cards = [];
                this.resetCardsOnly(); // Fill the deck with cards in order
                this.shuffle(); // Shuffle the deck immediately after filling
            }

            // Shuffles the deck using the Fisher-Yates algorithm
            shuffle() {
                for (let i = this.cards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]]; // Swap places
                }
            }

            // Creates a standard 52-card deck WITHOUT shuffling it
            resetCardsOnly() {
                const suits = ['H', 'D', 'C', 'S'];
                const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
                this.cards = []; // Ensure the deck is empty before filling
                for (const suit of suits) {
                    for (const rank of ranks) {
                        this.cards.push(new Card(suit, rank));
                    }
                }
            }

            // Resets the deck completely (fills and shuffles)
            reset() {
                this.resetCardsOnly();
                this.shuffle();
            }

            // Draws a card from the top of the deck
            draw() {
                if (this.cards.length === 0) {
                    showMessageBox(game.texts[game.currentLanguage].deckEmptyMessage);
                    return null;
                }
                return this.cards.pop();
            }

            // Returns the number of cards left in the deck
            remaining() {
                return this.cards.length;
            }
        }

        // Web Audio API for card dealing sound
        let audioContext = null; // Global AudioContext instance
        let lastCardDealSoundTime = 0;
        const cardDealSoundCooldown = 0.3; // 300ms cooldown

        // Function to play card dealing sound using Web Audio API
        async function playCardDealSound() {
            if (!game.isSoundEnabled) {
                console.log("Sound is disabled.");
                return;
            }

            // Lazy initialization of AudioContext
            if (!audioContext) {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!window.AudioContext) {
                    console.error("Web Audio API is not supported in this browser.");
                    return;
                }
                audioContext = new AudioContext();
                console.log("AudioContext created.");
            }

            // Resume context if suspended (required by most browsers for autoplay)
            if (audioContext.state === 'suspended') {
                try {
                    await audioContext.resume();
                    console.log("Audio context resumed successfully.");
                } catch (e) {
                    console.error("Error resuming audio context:", e);
                    return;
                }
            }

            const now = audioContext.currentTime;
            if (now - lastCardDealSoundTime > cardDealSoundCooldown) {
                console.log("Playing card deal sound at:", now);

                try {
                    const duration = 0.5; // Total duration of the shaking sound
                    const numClicks = 8; // Number of individual "clicks"
                    const clickDuration = 0.05; // Duration of each click

                    for (let i = 0; i < numClicks; i++) {
                        const startTime = audioContext.currentTime + (i * (duration / numClicks));

                        // Create a short burst of white noise for the "click"
                        const bufferSize = audioContext.sampleRate * clickDuration;
                        const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                        const output = noiseBuffer.getChannelData(0);
                        for (let j = 0; j < bufferSize; j++) {
                            output[j] = Math.random() * 0.8 - 0.4; // Slightly lower amplitude noise
                        }

                        const noiseSource = audioContext.createBufferSource();
                        noiseSource.buffer = noiseBuffer;

                        const gainNode = audioContext.createGain();
                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(0.4 + Math.random() * 0.2, startTime + 0.01); // Quick attack with slight randomness
                        gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + clickDuration); // Fast decay

                        // Add a bandpass filter for a "scratchier" sound
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'bandpass';
                        filter.frequency.setValueAtTime(1500, startTime);
                        filter.Q.setValueAtTime(0.8, startTime);

                        noiseSource.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        noiseSource.start(startTime);
                        noiseSource.stop(startTime + clickDuration);
                    }
                } catch (e) {
                    console.error("Failed to generate and play sound:", e);
                }

                lastCardDealSoundTime = now;
            } else {
                console.log("Card deal sound skipped due to cooldown.");
            }
        }

        // Text content for different languages
        const texts = {
            en: {
                gameTitle: "‚ô†Ô∏è Single Player Poker", // Updated title
                drawsLeft: "Draws left:",
                bestHand: "Best hand:",
                discardButton: "üîÑ Discard selected cards",
                standButton: "‚úã Stand",
                continueButton: "‚ñ∂Ô∏è Continue Game",
                newGameButton: "‚ú® New Game",
                soundOn: "üîä Sound On",
                soundOff: "üîá Sound Off",
                cardsLeft: "Cards left:",
                highScoreTitle: "High Score", // Changed to just text, emoji is in HTML
                savedTotalScore: "Saved Total Score:", // New text
                handLabel: "Hand",
                pointsLabel: "Points:",
                totalScore: "Total Score:",
                deckEmptyMessage: "The deck is empty!",
                selectCardsMessage: "Select at least one card to discard.",
                couldNotDiscardMessage: "The deck is empty, could not discard all cards.",
                allDrawsUsedMessage: (totalScore) => `Cards are out! Game over. üéâ Your total score: ${totalScore}`,
                gameOverMessage: (totalScore) => `Game over. üéâ Your total score: ${totalScore}`,
                standMessage: "You chose to stand. Your final hand is displayed.",
                menuTitle: "Menu",
                helpButton: "‚ùì Help", // New text for help button
                helpDescription: `
                    Welcome to Single Player Poker!
                    
                    The goal is to get the best possible poker hand.
                    
                    How to Play:
                    1.  You start with 5 cards.
                    2.  Click on the cards you want to discard (they will be highlighted).
                    3.  Click "Discard selected cards" to get new cards from the deck.
                    4.  You have 3 draws per game.
                    5.  You can "Stand" at any time to end your current hand.
                    6.  When a hand ends (after 3 draws or you stand), your hand's score is added to the High Score list.
                    7.  Click "Continue Game" to deal a new hand from the remaining cards in the deck.
                    8.  The game ends when there are not enough cards left to deal a full hand (5 cards).
                    9.  Your total score is saved and displayed.
                    
                    Poker Hand Ranks (Highest to Lowest):
                    - Royal Straight Flush (10)
                    - Straight Flush (9)
                    - Four of a Kind (8)
                    - Full House (7)
                    - Flush (6)
                    - Straight (5)
                    - Three of a Kind (4)
                    - Two Pair (3)
                    - One Pair (2)
                    - High Card (1)
                    
                    Good luck!
                `,
                langMenuTitle: "üåê Language", // New text for language menu title
                backButton: "Back", // Text for back button
                langToggleEn: "English üá¨üáß", // Text for language toggle button when current is Swedish
                langToggleSv: "Svenska üá∏üá™"  // Text for language toggle button when current is English
            },
            sv: {
                gameTitle: "‚ô†Ô∏è Single Player Poker", // Updated title
                drawsLeft: "Drag kvar:",
                bestHand: "B√§sta hand:",
                discardButton: "üîÑ Byt valda kort",
                standButton: "‚úã Stanna",
                continueButton: "‚ñ∂Ô∏è Forts√§tt Spel",
                newGameButton: "‚ú® Nytt Spel",
                soundOn: "üîä Ljud P√•",
                soundOff: "üîá Ljud Av",
                cardsLeft: "Kort kvar:",
                highScoreTitle: "High Score", // Changed to just text, emoji is in HTML
                savedTotalScore: "Sparad total po√§ng:", // New text
                handLabel: "Hand",
                pointsLabel: "Po√§ng:",
                totalScore: "Total Po√§ng:",
                deckEmptyMessage: "Kortleken √§r tom!",
                selectCardsMessage: "V√§lj minst ett kort att byta ut.",
                couldNotDiscardMessage: "Kortleken √§r tom, kunde inte byta alla kort.",
                allDrawsUsedMessage: (totalScore) => `Korten √§r slut! Spelet √§r √∂ver. üéâ Din totala po√§ng: ${totalScore}`,
                gameOverMessage: (totalScore) => `Spelet √§r √∂ver. üéâ Din totala po√§ng: ${totalScore}`,
                standMessage: "Du valde att stanna. Din slutgiltiga hand visas.",
                menuTitle: "Meny",
                helpButton: "‚ùì Hj√§lp", // New text for help button
                helpDescription: `
                    V√§lkommen till Single Player Poker!
                    
                    M√•let √§r att f√• den b√§sta m√∂jliga pokerhanden.
                    
                    S√• h√§r spelar du:
                    1.  Du b√∂rjar med 5 kort.
                    2.  Klicka p√• de kort du vill g√∂ra dig av med (de markeras).
                    3.  Klicka p√• "Byt valda kort" f√∂r att f√• nya kort fr√•n h√∂gen.
                    4.  Du f√•r g√∂ra 3 drag per spel.
                    5.  Du kan "Stanna" n√§r som helst f√∂r att avsluta din nuvarande hand.
                    6.  N√§r en hand √§r slut (efter 3 drag eller du stannar), l√§ggs din hands po√§ng till i High Score-listan.
                    7.  Klicka p√• "Forts√§tt Spel" f√∂r att f√• en ny hand fr√•n de √•terst√•ende korten i h√∂gen.
                    8.  Spelet √§r slut n√§r det inte finns tillr√§ckligt med kort kvar f√∂r att dela ut en full hand (5 kort).
                    9.  Din totala po√§ng sparas och visas.
                    
                    Pokerhandrankning (h√∂gst till l√§gst):
                    - Royal Straight Flush (10)
                    - Straight Flush (9)
                    - Fyrtal (8)
                    - K√•k (Full House) (7)
                    - F√§rg (Flush) (6)
                    - Stege (Straight) (5)
                    - Triss (Three of a Kind) (4)
                    - Tv√•par (Two Pair) (3)
                    - Par (One Pair) (2)
                    - H√∂gt Kort (High Card) (1)
                    
                    Lycka till!
                `,
                langMenuTitle: "üåê Spr√•k", // New text for language menu title
                backButton: "Tillbaka", // Text for back button
                langToggleEn: "English üá¨üáß", // Text for language toggle button when current is Swedish
                langToggleSv: "Svenska üá∏üá™"  // Text for language toggle button when current is English
            }
        };


        // Main game object
        const game = {
            deck: null,
            playerHand: [],
            drawsRemaining: 3,
            maxDraws: 3, // Max number of draws
            isGameOver: false,
            scores: [], // New array to store scores for each hand
            isSoundEnabled: true, // Sound on by default
            currentLanguage: 'en', // Default language is English
            texts: texts, // Reference to the language object

            // DOM Elements - Initialized in initializeDOMElements
            gameTitleEl: null,
            drawCountLabelEl: null,
            drawCountEl: null,
            handResultLabelEl: null,
            handResultEl: null,
            drawButton: null,
            standButton: null,
            continueButton: null,
            newGameButton: null,
            toggleSoundButton: null,
            helpButton: null, // New help button DOM element
            languageToggleButton: null, // New language toggle button
            remainingCardsLabelEl: null,
            remainingCardsEl: null,
            highScoreTitleEl: null,
            highScoreTitleTextEl: null, // Added for the text part of the H2
            savedTotalScoreDisplayEl: null, // The span inside H2 for saved score
            scoreListItemsEl: null,
            totalScoreEl: null,
            menuTitleEl: null, // No longer used for offcanvas title
            langSvButton: null, // No longer separate buttons
            langEnButton: null, // No longer separate buttons
            mainMenuOptionsEl: null, // No longer used for menu sections
            languageOptionsEl: null, // No longer used for menu sections
            langMenuButton: null, // No longer used for menu navigation
            backButton: null, // No longer used for menu navigation

            // New method to initialize DOM elements
            initializeDOMElements() {
                this.gameTitleEl = document.getElementById('game-title');
                this.drawCountLabelEl = document.getElementById('draw-count-label');
                this.drawCountEl = this.drawCountLabelEl ? this.drawCountLabelEl.querySelector('#draw-count') : null;
                this.handResultLabelEl = document.getElementById('hand-result-label');
                this.handResultEl = this.handResultLabelEl ? this.handResultLabelEl.querySelector('#hand-result') : null;

                this.drawButton = document.getElementById('draw-button');
                this.standButton = document.getElementById('stand-button');
                this.continueButton = document.getElementById('continue-game-button');
                this.newGameButton = document.getElementById('new-game-button');
                this.toggleSoundButton = document.getElementById('toggle-sound-button');
                this.helpButton = document.getElementById('help-button'); // Initialize new button
                this.languageToggleButton = document.getElementById('language-toggle-button'); // Initialize new language toggle button
                this.remainingCardsLabelEl = document.getElementById('remaining-cards-label');
                this.remainingCardsEl = this.remainingCardsLabelEl ? this.remainingCardsLabelEl.querySelector('#remaining-cards') : null;
                
                this.highScoreListEl = document.getElementById('high-score-list');
                this.highScoreTitleEl = document.getElementById('high-score-title'); // Parent of high-score-title-text and saved-total-score-display
                this.highScoreTitleTextEl = document.getElementById('high-score-title-text'); // Get the span for the text
                this.savedTotalScoreDisplayEl = document.getElementById('saved-total-score-display'); // Get the span for saved score

                this.scoreListItemsEl = document.getElementById('score-list-items');
                this.totalScoreEl = document.getElementById('total-score');
                // this.menuTitleEl = document.getElementById('offcanvasMenuLabel'); // No longer used for offcanvas title
                // this.langSvButton = document.getElementById('lang-sv-button'); // No longer separate buttons
                // this.langEnButton = document.getElementById('lang-en-button'); // No longer separate buttons

                // No longer needed for menu sections
                // this.mainMenuOptionsEl = document.getElementById('main-menu-options');
                // this.languageOptionsEl = document.getElementById('language-options');
                // this.langMenuButton = document.getElementById('lang-menu-button');
                // this.backButton = document.getElementById('back-button');
                this.playerHandEl = document.getElementById('player-hand'); // Ensure playerHandEl is initialized here
            },

            // Helper function to create a card DOM element
            createCardElement(card, index) {
                const cardEl = document.createElement('div');
                cardEl.classList.add('card', 'rounded-xl', 'flex', 'flex-col', 'justify-between', 'items-center', 'p-2', 'shadow-lg', 'transition-all', 'duration-200');
                if (card.isRed()) {
                    cardEl.classList.add('red');
                }
                cardEl.dataset.index = index; // Store index to know which card was selected

                cardEl.innerHTML = `
                    <div class="card-top-left">${card.rank}${card.getSuitSymbol()}</div>
                    <div class="card-rank">${card.rank}</div>
                    <div class="card-suit">${card.getSuitSymbol()}</div>
                    <div class="card-bottom-right">${card.rank}${card.getSuitSymbol()}</div>
                `;
                cardEl.addEventListener('click', () => this.toggleCardSelection(cardEl));
                return cardEl;
            },

            // Sets the language of the game UI
            setLanguage(lang) {
                this.currentLanguage = lang;
                const t = this.texts[lang];

                if (this.gameTitleEl) {
                    this.gameTitleEl.textContent = t.gameTitle;
                } else {
                    console.error("Error: gameTitleEl is null. Cannot set game title. Re-initializing and trying again.");
                    this.gameTitleEl = document.getElementById('game-title');
                    if (this.gameTitleEl) {
                         this.gameTitleEl.textContent = t.gameTitle;
                    }
                }
                
                if (this.drawCountLabelEl) {
                    this.drawCountLabelEl.innerHTML = `${t.drawsLeft} <span id="draw-count" class="text-blue-300"></span>`;
                    this.drawCountEl = document.getElementById('draw-count'); // Re-get reference
                    if (this.drawCountEl) this.drawCountEl.textContent = this.drawsRemaining;
                } else {
                    console.error("Error: drawCountLabelEl is null. Cannot set draws left label.");
                    this.drawCountLabelEl = document.getElementById('draw-count-label');
                    if (this.drawCountLabelEl) {
                        this.drawCountLabelEl.innerHTML = `${t.drawsLeft} <span id="draw-count" class="text-blue-300"></span>`;
                        this.drawCountEl = document.getElementById('draw-count');
                        if (this.drawCountEl) this.drawCountEl.textContent = this.drawsRemaining;
                    }
                }

                if (this.handResultLabelEl) {
                    this.handResultLabelEl.innerHTML = `${t.bestHand} <span id="hand-result" class="text-green-300"></span>`;
                    this.handResultEl = document.getElementById('hand-result'); // Re-get reference
                    if (this.handResultEl) this.handResultEl.textContent = this.evaluateHand(this.playerHand).name;
                } else {
                    console.error("Error: handResultLabelEl is null. Cannot set best hand label.");
                    this.handResultLabelEl = document.getElementById('hand-result-label');
                    if (this.handResultLabelEl) {
                        this.handResultLabelEl.innerHTML = `${t.bestHand} <span id="hand-result" class="text-green-300"></span>`;
                        this.handResultEl = document.getElementById('hand-result');
                        if (this.handResultEl) this.handResultEl.textContent = this.evaluateHand(this.playerHand).name;
                    }
                }

                if (this.drawButton) this.drawButton.textContent = t.discardButton;
                if (this.standButton) this.standButton.textContent = t.standButton;
                if (this.continueButton) this.continueButton.textContent = t.continueButton;
                if (this.newGameButton) this.newGameButton.textContent = t.newGameButton;
                if (this.toggleSoundButton) this.toggleSoundButton.textContent = this.isSoundEnabled ? t.soundOn : t.soundOff;
                if (this.helpButton) this.helpButton.textContent = t.helpButton; // Set text for new help button
                
                // Update language toggle button
                if (this.languageToggleButton) {
                    if (lang === 'en') {
                        this.languageToggleButton.innerHTML = `${this.texts['sv'].langToggleSv} <img src="https://placehold.co/20x15/fff/000?text=SE" alt="Swedish Flag" class="flag-icon">`; // Show Swedish flag to switch to Swedish
                    } else {
                        this.languageToggleButton.innerHTML = `${this.texts['en'].langToggleEn} <img src="https://placehold.co/20x15/fff/000?text=US" alt="US Flag" class="flag-icon">`; // Show US flag to switch to English
                    }
                }

                if (this.remainingCardsLabelEl) {
                    this.remainingCardsLabelEl.innerHTML = `${t.cardsLeft} <span id="remaining-cards"></span>`;
                    this.remainingCardsEl = document.getElementById('remaining-cards'); // Re-get reference
                    if (this.remainingCardsEl) this.remainingCardsEl.textContent = this.deck ? this.deck.remaining() : 52;
                } else {
                    console.error("Error: remainingCardsLabelEl is null. Cannot set cards left label.");
                    this.remainingCardsLabelEl = document.getElementById('remaining-cards-label');
                    if (this.remainingCardsLabelEl) {
                        this.remainingCardsLabelEl.innerHTML = `${t.cardsLeft} <span id="remaining-cards"></span>`;
                        this.remainingCardsEl = document.getElementById('remaining-cards');
                        if (this.remainingCardsEl) this.remainingCardsEl.textContent = this.deck ? this.deck.remaining() : 52;
                    }
                }

                // Update High Score title text
                if (this.highScoreTitleTextEl) {
                    this.highScoreTitleTextEl.textContent = t.highScoreTitle;
                } else {
                    console.error("Error: highScoreTitleTextEl is null. Cannot set high score title text.");
                    this.highScoreTitleTextEl = document.getElementById('high-score-title-text');
                    if (this.highScoreTitleTextEl) this.highScoreTitleTextEl.textContent = t.highScoreTitle;
                }

                // Update saved total score display
                if (this.savedTotalScoreDisplayEl) {
                    const savedScore = getCookie('pokerTotalScore');
                    this.savedTotalScoreDisplayEl.textContent = savedScore ? `(${savedScore}p)` : ''; // Format (XXp)
                } else {
                    console.error("Error: savedTotalScoreDisplayEl is null. Cannot set saved total score.");
                    this.savedTotalScoreDisplayEl = document.getElementById('saved-total-score-display');
                    if (this.savedTotalScoreDisplayEl) {
                        const savedScore = getCookie('pokerTotalScore');
                        this.savedTotalScoreDisplayEl.textContent = savedScore ? `(${savedScore}p)` : '';
                    }
                }


                // Re-render high score list and total score to update labels
                this.renderHighScoreList();
            },

            // Shows the main menu options (no longer applicable with direct buttons)
            showMainMenu() {
                // This function is no longer directly used as there's no offcanvas menu navigation
                // It might be called by startGame, but its effects are now minimal.
            },

            // Shows the language selection options (no longer applicable with direct buttons)
            showLanguageOptions() {
                // This function is no longer directly used. Language toggle is a single button.
            },

            // Starts a new game
            startGame() {
                this.initializeDOMElements(); // Call this first to ensure elements are ready
                this.deck = new Deck();
                this.scores = []; // Clear scores from previous game
                this.isGameOver = false;

                this.dealNewRound(); // Start the first round
                this.setLanguage(this.currentLanguage); // Set language on start
                // this.showMainMenu(); // No longer needed
            },

            // Deals a new hand for a new round
            dealNewRound() {
                // Check if there are enough cards for a new hand
                if (this.deck.remaining() < 5) {
                    this.endGame(true); // Game over if cards run out
                    return;
                }

                this.playerHand = [];
                this.drawsRemaining = this.maxDraws;

                // Show game buttons, hide continue/new game
                if (this.drawButton) this.drawButton.classList.remove('hidden');
                if (this.standButton) this.standButton.classList.remove('hidden');
                if (this.newGameButton) this.newGameButton.classList.add('hidden');
                
                // Forts√§tt-knappen √§r alltid synlig men inaktiveras vid ny runda
                if (this.continueButton) this.continueButton.disabled = true; 

                if (this.drawButton) this.drawButton.disabled = false;
                if (this.standButton) this.standButton.disabled = false;

                for (let i = 0; i < 5; i++) {
                    const card = this.deck.draw();
                    if (card) {
                        this.playerHand.push(card);
                    }
                }
                this.updateUI();
                playCardDealSound(); // Play sound when new hand is dealt
            },

            // Updates the UI
            updateUI() {
                // Only render hand if not in the middle of card animation
                if (!this.isAnimatingCards) {
                    this.renderHand();
                }
                if (this.drawCountEl) this.drawCountEl.textContent = this.drawsRemaining;
                if (this.remainingCardsEl) this.remainingCardsEl.textContent = this.deck.remaining();
                const handEvaluation = this.evaluateHand(this.playerHand);
                if (this.handResultEl) this.handResultEl.textContent = handEvaluation.name;

                // Handle button states
                if (this.isGameOver) {
                    if (this.drawButton) this.drawButton.disabled = true;
                    if (this.standButton) this.standButton.disabled = true;
                    if (this.continueButton) this.continueButton.disabled = true; // Disable continue when game is completely over
                    if (this.newGameButton) this.newGameButton.classList.remove('hidden'); // Show New Game button
                } else if (this.drawsRemaining === 0) {
                    if (this.drawButton) this.drawButton.disabled = true; // No more draws in this hand
                    if (this.standButton) this.standButton.disabled = true; // Cannot stand if draws are out
                    if (this.continueButton) this.continueButton.disabled = false; // Enable continue when round is over
                    if (this.newGameButton) this.newGameButton.classList.add('hidden');
                } else {
                    if (this.drawButton) this.drawButton.disabled = false;
                    if (this.standButton) this.standButton.disabled = false;
                    if (this.continueButton) this.continueButton.disabled = true; // Inaktivera forts√§tt under p√•g√•ende runda
                    if (this.newGameButton) this.newGameButton.classList.add('hidden');
                }
            },

            // Renders the player's hand in the DOM
            renderHand() {
                if (this.playerHandEl) { // Add check for playerHandEl
                    this.playerHandEl.innerHTML = ''; // Clear existing cards
                    this.playerHand.forEach((card, index) => {
                        const cardEl = this.createCardElement(card, index);
                        this.playerHandEl.appendChild(cardEl);
                    });
                }
            },

            // Toggles card selection
            toggleCardSelection(cardEl) {
                if (this.isGameOver || this.drawsRemaining === 0) return; // Cannot select cards if game is over or no draws left
                cardEl.classList.toggle('selected');
            },

            // Handles card exchange with animations
            async handleDraw() {
                if (this.drawsRemaining === 0) {
                    return; // Abort if no draws left
                }

                const selectedCards = Array.from(this.playerHandEl.children).filter(cardEl =>
                    cardEl.classList.contains('selected')
                );

                if (selectedCards.length === 0) {
                    showMessageBox(this.texts[this.currentLanguage].selectCardsMessage);
                    return;
                }

                if (this.drawButton) this.drawButton.disabled = true; // Disable buttons during animation
                if (this.standButton) this.standButton.disabled = true;
                if (this.continueButton) this.continueButton.disabled = true; // Disable continue during animation
                this.isAnimatingCards = true; // Mark that animation is in progress

                let cardsReplacedCount = 0;
                const animationDelay = 300; // Matches CSS animation duration

                // Animate out selected cards first
                const exitPromises = selectedCards.map(cardEl => {
                    return new Promise(resolve => {
                        cardEl.classList.add('card-exit');
                        setTimeout(() => {
                            cardEl.remove(); // Remove card from DOM after exit animation
                            resolve();
                        }, animationDelay);
                    });
                });

                await Promise.all(exitPromises); // Wait until all exit animations are complete

                // Play sound when cards are exchanged
                playCardDealSound();

                // Replace cards and animate in new ones
                const entryPromises = [];
                for (const cardEl of selectedCards) {
                    const indexToReplace = parseInt(cardEl.dataset.index);
                    const newCard = this.deck.draw();

                    if (newCard) {
                        this.playerHand[indexToReplace] = newCard;
                        const newCardEl = this.createCardElement(newCard, indexToReplace);
                        newCardEl.classList.add('card-enter'); // Add entry animation
                        
                        // Find the correct position to insert the new card
                        const referenceNode = this.playerHandEl.children[indexToReplace];
                        if (referenceNode) {
                            this.playerHandEl.insertBefore(newCardEl, referenceNode);
                        } else {
                            this.playerHandEl.appendChild(newCardEl);
                        }

                        entryPromises.push(new Promise(resolve => {
                            setTimeout(() => {
                                newCardEl.classList.remove('card-enter');
                                resolve();
                            }, animationDelay);
                        }));
                        cardsReplacedCount++;
                    } else {
                        showMessageBox(this.texts[this.currentLanguage].couldNotDiscardMessage);
                        this.isGameOver = true; // Game is over if deck is empty
                        break; // Abort if deck is empty
                    }
                }

                await Promise.all(entryPromises); // Wait until all entry animations are complete

                this.isAnimatingCards = false; // Animation complete

                if (cardsReplacedCount > 0) {
                    this.drawsRemaining--;
                }

                this.updateUI(); // Update UI after animations and card exchanges

                if (this.drawsRemaining === 0 || this.isGameOver) {
                    this.endHand(); // End the hand when draws are out or game is over
                }
            },

            // Handles player choosing to stand
            handleStand() {
                this.endHand(); // End the hand
            },

            // Ends the current hand
            endHand() {
                // Save the score for the current hand
                const handEvaluation = this.evaluateHand(this.playerHand);
                this.scores.push(handEvaluation); // Save the entire object
                this.drawsRemaining = 0; // Set draws left to 0 to activate "Continue Game" button
                this.updateUI(); // Update UI to show buttons correctly
                this.renderHighScoreList(); // Update high score list after each hand

                // Check if there are enough cards for the next round
                if (this.deck.remaining() < 5) {
                    this.endGame(true); // Game is completely over
                }
            },

            // Ends the entire game (when the deck is empty)
            endGame(deckEmpty = false) {
                this.isGameOver = true;
                this.updateUI(); // Update UI to show New Game button and hide others

                let finalMessage = "";
                let totalScore = this.scores.reduce((sum, hand) => sum + hand.score, 0);

                // Save total score to cookie
                setCookie('pokerTotalScore', totalScore, 365); // Save for 365 days

                if (deckEmpty) {
                    finalMessage = this.texts[this.currentLanguage].allDrawsUsedMessage(totalScore);
                } else {
                    finalMessage = this.texts[this.currentLanguage].gameOverMessage(totalScore);
                }
                showMessageBox(finalMessage);
                // High score list is already visible and updated
            },

            // Function for evaluating the poker hand and returning name + score
            evaluateHand(hand) {
                if (hand.length !== 5) return { name: "Invalid hand", score: 0 };

                const ranks = hand.map(card => card.rank);
                const suits = hand.map(card => card.suit);

                const rankValues = ranks.map(r => {
                    if (r === 'J') return 11;
                    if (r === 'Q') return 12;
                    if (r === 'K') return 13;
                    if (r === 'A') return 14;
                    return parseInt(r);
                }).sort((a, b) => a - b);

                const rankCounts = {};
                ranks.forEach(r => { rankCounts[r] = (rankCounts[r] || 0) + 1; });
                const suitCounts = {};
                suits.forEach(s => { suitCounts[s] = (suitCounts[s] || 0) + 1; });

                const numPairs = Object.values(rankCounts).filter(count => count === 2).length;
                const numThrees = Object.values(rankCounts).filter(count => count === 3).length;
                const numFours = Object.values(rankCounts).filter(count => count === 4).length;
                const isFlush = Object.values(suitCounts).some(count => count >= 5);

                let isStraight = true;
                // Handle Ace as low for straight (A, 2, 3, 4, 5)
                const lowAceRankValues = rankValues.includes(14) ? [...rankValues.filter(r => r !== 14), 1].sort((a, b) => a - b) : rankValues;

                for (let i = 0; i < lowAceRankValues.length - 1; i++) {
                    if (lowAceRankValues[i + 1] !== lowAceRankValues[i] + 1) {
                        isStraight = false;
                        break;
                    }
                }
                // If not a low ace straight, try normal straight
                if (!isStraight) {
                    isStraight = true;
                    for (let i = 0; i < rankValues.length - 1; i++) {
                        if (rankValues[i + 1] !== rankValues[i] + 1) {
                            isStraight = false;
                            break;
                        }
                        // Special case for Ace as highest card in straight (10, J, Q, K, A)
                        if (rankValues[i] === 10 && rankValues[i+1] === 11 && rankValues[i+2] === 12 && rankValues[i+3] === 13 && rankValues[i+4] === 14) {
                            isStraight = true;
                            break;
                        }
                    }
                }

                // Evaluate hand in descending order of strength
                if (isStraight && isFlush && (rankValues[4] === 14 && rankValues[0] === 10)) return { name: "Royal Straight Flush!", score: 10 };
                if (isStraight && isFlush) return { name: "Straight Flush", score: 9 };
                if (numFours === 1) return { name: "Four of a Kind", score: 8 };
                if (numThrees === 1 && numPairs === 1) return { name: "Full House", score: 7 };
                if (isFlush) return { name: "Flush", score: 6 };
                if (isStraight) return { name: "Straight", score: 5 };
                if (numThrees === 1) return { name: "Three of a Kind", score: 4 };
                if (numPairs === 2) return { name: "Two Pair", score: 3 };
                if (numPairs === 1) return { name: "One Pair", score: 2 };

                const highestRank = ranks[rankValues.length - 1];
                return { name: `High Card: ${highestRank}`, score: 1 };
            },

            // Renders the high score list
            renderHighScoreList() {
                if (this.scoreListItemsEl) { // Add check for scoreListItemsEl
                    this.scoreListItemsEl.innerHTML = ''; // Clear existing list items
                    let totalScore = 0;
                    // Iterate in reverse to show latest result at the top
                    for (let i = this.scores.length - 1; i >= 0; i--) {
                        const handResult = this.scores[i];
                        const listItem = document.createElement('li');
                        // Use original index for display (Hand 1, Hand 2, etc.)
                        listItem.innerHTML = `<span>${this.texts[this.currentLanguage].handLabel} ${i + 1}: ${handResult.name}</span> <span>${this.texts[this.currentLanguage].pointsLabel} ${handResult.score}</span>`;
                        this.scoreListItemsEl.appendChild(listItem);
                        totalScore += handResult.score;
                    }
                    if (this.totalScoreEl) { // Add check for totalScoreEl
                        this.totalScoreEl.textContent = `${this.texts[this.currentLanguage].totalScore} ${totalScore}`;
                    }
                }
                // Update saved total score display
                if (this.savedTotalScoreDisplayEl) { // Changed from savedTotalScoreEl to savedTotalScoreDisplayEl
                    const savedScore = getCookie('pokerTotalScore');
                    this.savedTotalScoreDisplayEl.textContent = savedScore ? `(${savedScore}p)` : '';
                }
            },

            // Toggles sound on/off
            toggleSound() {
                this.isSoundEnabled = !this.isSoundEnabled;
                if (this.toggleSoundButton) { // Add check for toggleSoundButton
                    this.toggleSoundButton.textContent = this.isSoundEnabled ? this.texts[this.currentLanguage].soundOn : this.texts[this.currentLanguage].soundOff;
                }
            }
        };

        // Event listeners for buttons
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize AudioContext on first user interaction
            let audioContextInitialized = false;
            const initializeAudioContext = async () => {
                if (!audioContextInitialized) {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!window.AudioContext) {
                        console.error("Web Audio API is not supported in this browser.");
                        return;
                    }
                    if (!audioContext) { // Create context only once
                        audioContext = new AudioContext();
                        console.log("AudioContext created.");
                    }
                    if (audioContext.state === 'suspended') {
                        try {
                            await audioContext.resume();
                            console.log("Audio context resumed successfully.");
                        } catch (e) {
                            console.error("Error resuming audio context:", e);
                            return;
                        }
                    }
                    audioContextInitialized = true;
                    console.log("Audio context is now running.");
                }
            };

            // Call initializeDOMElements at the very beginning of DOMContentLoaded
            game.initializeDOMElements();

            // Attach initializeAudioContext to any button click, but only run once
            document.body.addEventListener('click', (event) => {
                if (event.target.tagName === 'BUTTON') {
                    initializeAudioContext();
                }
            }, { once: true });

            if (game.drawButton) game.drawButton.addEventListener('click', () => game.handleDraw());
            if (game.standButton) game.standButton.addEventListener('click', () => game.handleStand());
            if (game.continueButton) game.continueButton.addEventListener('click', () => game.dealNewRound());
            if (game.newGameButton) game.newGameButton.addEventListener('click', () => game.startGame());
            if (game.toggleSoundButton) game.toggleSoundButton.addEventListener('click', () => game.toggleSound()); // Event listener for sound button
            if (game.helpButton) game.helpButton.addEventListener('click', () => { // Event listener for help button
                showMessageBox(game.texts[game.currentLanguage].helpDescription);
            });

            // Language toggle button logic
            const languageToggleButton = document.getElementById('language-toggle-button');
            if (languageToggleButton) {
                languageToggleButton.addEventListener('click', () => {
                    if (game.currentLanguage === 'en') {
                        game.setLanguage('sv');
                    } else {
                        game.setLanguage('en');
                    }
                });
            }

            // Start the game when the page loads
            game.startGame();
        });
    </script>
</body>
</html>